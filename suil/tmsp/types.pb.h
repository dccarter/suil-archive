// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: types.proto

#ifndef PROTOBUF_types_2eproto__INCLUDED
#define PROTOBUF_types_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "protob/google/protobuf/timestamp.pb.h"
#include "protob/github.com/gogo/protobuf/gogoproto/gogo.pb.h"
#include "protob/github.com/tendermint/tendermint/libs/common/types.pb.h"
#include "protob/github.com/tendermint/tendermint/crypto/merkle/merkle.pb.h"
// @@protoc_insertion_point(includes)
namespace common {
class KI64Pair;
class KI64PairDefaultTypeInternal;
extern KI64PairDefaultTypeInternal _KI64Pair_default_instance_;
class KVPair;
class KVPairDefaultTypeInternal;
extern KVPairDefaultTypeInternal _KVPair_default_instance_;
}  // namespace common
namespace gogoproto {
}  // namespace gogoproto
namespace google {
namespace protobuf {
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google
namespace merkle {
class Proof;
class ProofDefaultTypeInternal;
extern ProofDefaultTypeInternal _Proof_default_instance_;
class ProofOp;
class ProofOpDefaultTypeInternal;
extern ProofOpDefaultTypeInternal _ProofOp_default_instance_;
}  // namespace merkle
namespace types {
class BlockID;
class BlockIDDefaultTypeInternal;
extern BlockIDDefaultTypeInternal _BlockID_default_instance_;
class BlockSizeParams;
class BlockSizeParamsDefaultTypeInternal;
extern BlockSizeParamsDefaultTypeInternal _BlockSizeParams_default_instance_;
class ConsensusParams;
class ConsensusParamsDefaultTypeInternal;
extern ConsensusParamsDefaultTypeInternal _ConsensusParams_default_instance_;
class Evidence;
class EvidenceDefaultTypeInternal;
extern EvidenceDefaultTypeInternal _Evidence_default_instance_;
class EvidenceParams;
class EvidenceParamsDefaultTypeInternal;
extern EvidenceParamsDefaultTypeInternal _EvidenceParams_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class LastCommitInfo;
class LastCommitInfoDefaultTypeInternal;
extern LastCommitInfoDefaultTypeInternal _LastCommitInfo_default_instance_;
class PartSetHeader;
class PartSetHeaderDefaultTypeInternal;
extern PartSetHeaderDefaultTypeInternal _PartSetHeader_default_instance_;
class PubKey;
class PubKeyDefaultTypeInternal;
extern PubKeyDefaultTypeInternal _PubKey_default_instance_;
class Request;
class RequestDefaultTypeInternal;
extern RequestDefaultTypeInternal _Request_default_instance_;
class RequestBeginBlock;
class RequestBeginBlockDefaultTypeInternal;
extern RequestBeginBlockDefaultTypeInternal _RequestBeginBlock_default_instance_;
class RequestCheckTx;
class RequestCheckTxDefaultTypeInternal;
extern RequestCheckTxDefaultTypeInternal _RequestCheckTx_default_instance_;
class RequestCommit;
class RequestCommitDefaultTypeInternal;
extern RequestCommitDefaultTypeInternal _RequestCommit_default_instance_;
class RequestDeliverTx;
class RequestDeliverTxDefaultTypeInternal;
extern RequestDeliverTxDefaultTypeInternal _RequestDeliverTx_default_instance_;
class RequestEcho;
class RequestEchoDefaultTypeInternal;
extern RequestEchoDefaultTypeInternal _RequestEcho_default_instance_;
class RequestEndBlock;
class RequestEndBlockDefaultTypeInternal;
extern RequestEndBlockDefaultTypeInternal _RequestEndBlock_default_instance_;
class RequestFlush;
class RequestFlushDefaultTypeInternal;
extern RequestFlushDefaultTypeInternal _RequestFlush_default_instance_;
class RequestInfo;
class RequestInfoDefaultTypeInternal;
extern RequestInfoDefaultTypeInternal _RequestInfo_default_instance_;
class RequestInitChain;
class RequestInitChainDefaultTypeInternal;
extern RequestInitChainDefaultTypeInternal _RequestInitChain_default_instance_;
class RequestQuery;
class RequestQueryDefaultTypeInternal;
extern RequestQueryDefaultTypeInternal _RequestQuery_default_instance_;
class RequestSetOption;
class RequestSetOptionDefaultTypeInternal;
extern RequestSetOptionDefaultTypeInternal _RequestSetOption_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class ResponseBeginBlock;
class ResponseBeginBlockDefaultTypeInternal;
extern ResponseBeginBlockDefaultTypeInternal _ResponseBeginBlock_default_instance_;
class ResponseCheckTx;
class ResponseCheckTxDefaultTypeInternal;
extern ResponseCheckTxDefaultTypeInternal _ResponseCheckTx_default_instance_;
class ResponseCommit;
class ResponseCommitDefaultTypeInternal;
extern ResponseCommitDefaultTypeInternal _ResponseCommit_default_instance_;
class ResponseDeliverTx;
class ResponseDeliverTxDefaultTypeInternal;
extern ResponseDeliverTxDefaultTypeInternal _ResponseDeliverTx_default_instance_;
class ResponseEcho;
class ResponseEchoDefaultTypeInternal;
extern ResponseEchoDefaultTypeInternal _ResponseEcho_default_instance_;
class ResponseEndBlock;
class ResponseEndBlockDefaultTypeInternal;
extern ResponseEndBlockDefaultTypeInternal _ResponseEndBlock_default_instance_;
class ResponseException;
class ResponseExceptionDefaultTypeInternal;
extern ResponseExceptionDefaultTypeInternal _ResponseException_default_instance_;
class ResponseFlush;
class ResponseFlushDefaultTypeInternal;
extern ResponseFlushDefaultTypeInternal _ResponseFlush_default_instance_;
class ResponseInfo;
class ResponseInfoDefaultTypeInternal;
extern ResponseInfoDefaultTypeInternal _ResponseInfo_default_instance_;
class ResponseInitChain;
class ResponseInitChainDefaultTypeInternal;
extern ResponseInitChainDefaultTypeInternal _ResponseInitChain_default_instance_;
class ResponseQuery;
class ResponseQueryDefaultTypeInternal;
extern ResponseQueryDefaultTypeInternal _ResponseQuery_default_instance_;
class ResponseSetOption;
class ResponseSetOptionDefaultTypeInternal;
extern ResponseSetOptionDefaultTypeInternal _ResponseSetOption_default_instance_;
class Validator;
class ValidatorDefaultTypeInternal;
extern ValidatorDefaultTypeInternal _Validator_default_instance_;
class ValidatorParams;
class ValidatorParamsDefaultTypeInternal;
extern ValidatorParamsDefaultTypeInternal _ValidatorParams_default_instance_;
class ValidatorUpdate;
class ValidatorUpdateDefaultTypeInternal;
extern ValidatorUpdateDefaultTypeInternal _ValidatorUpdate_default_instance_;
class Version;
class VersionDefaultTypeInternal;
extern VersionDefaultTypeInternal _Version_default_instance_;
class VoteInfo;
class VoteInfoDefaultTypeInternal;
extern VoteInfoDefaultTypeInternal _VoteInfo_default_instance_;
}  // namespace types

namespace types {

namespace protobuf_types_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_types_2eproto

// ===================================================================

class Request : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Request) */ {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  enum ValueCase {
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 19,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static inline const Request* internal_default_instance() {
    return reinterpret_cast<const Request*>(
               &_Request_default_instance_);
  }

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  inline Request* New() const PROTOBUF_FINAL { return New(NULL); }

  Request* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Request* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.RequestEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::types::RequestEcho& echo() const;
  ::types::RequestEcho* mutable_echo();
  ::types::RequestEcho* release_echo();
  void set_allocated_echo(::types::RequestEcho* echo);

  // .types.RequestFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::types::RequestFlush& flush() const;
  ::types::RequestFlush* mutable_flush();
  ::types::RequestFlush* release_flush();
  void set_allocated_flush(::types::RequestFlush* flush);

  // .types.RequestInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::types::RequestInfo& info() const;
  ::types::RequestInfo* mutable_info();
  ::types::RequestInfo* release_info();
  void set_allocated_info(::types::RequestInfo* info);

  // .types.RequestSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::types::RequestSetOption& set_option() const;
  ::types::RequestSetOption* mutable_set_option();
  ::types::RequestSetOption* release_set_option();
  void set_allocated_set_option(::types::RequestSetOption* set_option);

  // .types.RequestInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::types::RequestInitChain& init_chain() const;
  ::types::RequestInitChain* mutable_init_chain();
  ::types::RequestInitChain* release_init_chain();
  void set_allocated_init_chain(::types::RequestInitChain* init_chain);

  // .types.RequestQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::types::RequestQuery& query() const;
  ::types::RequestQuery* mutable_query();
  ::types::RequestQuery* release_query();
  void set_allocated_query(::types::RequestQuery* query);

  // .types.RequestBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::types::RequestBeginBlock& begin_block() const;
  ::types::RequestBeginBlock* mutable_begin_block();
  ::types::RequestBeginBlock* release_begin_block();
  void set_allocated_begin_block(::types::RequestBeginBlock* begin_block);

  // .types.RequestCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::types::RequestCheckTx& check_tx() const;
  ::types::RequestCheckTx* mutable_check_tx();
  ::types::RequestCheckTx* release_check_tx();
  void set_allocated_check_tx(::types::RequestCheckTx* check_tx);

  // .types.RequestDeliverTx deliver_tx = 19;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 19;
  const ::types::RequestDeliverTx& deliver_tx() const;
  ::types::RequestDeliverTx* mutable_deliver_tx();
  ::types::RequestDeliverTx* release_deliver_tx();
  void set_allocated_deliver_tx(::types::RequestDeliverTx* deliver_tx);

  // .types.RequestEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::types::RequestEndBlock& end_block() const;
  ::types::RequestEndBlock* mutable_end_block();
  ::types::RequestEndBlock* release_end_block();
  void set_allocated_end_block(::types::RequestEndBlock* end_block);

  // .types.RequestCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::types::RequestCommit& commit() const;
  ::types::RequestCommit* mutable_commit();
  ::types::RequestCommit* release_commit();
  void set_allocated_commit(::types::RequestCommit* commit);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:types.Request)
 private:
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::types::RequestEcho* echo_;
    ::types::RequestFlush* flush_;
    ::types::RequestInfo* info_;
    ::types::RequestSetOption* set_option_;
    ::types::RequestInitChain* init_chain_;
    ::types::RequestQuery* query_;
    ::types::RequestBeginBlock* begin_block_;
    ::types::RequestCheckTx* check_tx_;
    ::types::RequestDeliverTx* deliver_tx_;
    ::types::RequestEndBlock* end_block_;
    ::types::RequestCommit* commit_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestEcho : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestEcho) */ {
 public:
  RequestEcho();
  virtual ~RequestEcho();

  RequestEcho(const RequestEcho& from);

  inline RequestEcho& operator=(const RequestEcho& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEcho& default_instance();

  static inline const RequestEcho* internal_default_instance() {
    return reinterpret_cast<const RequestEcho*>(
               &_RequestEcho_default_instance_);
  }

  void Swap(RequestEcho* other);

  // implements Message ----------------------------------------------

  inline RequestEcho* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestEcho* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestEcho& from);
  void MergeFrom(const RequestEcho& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:types.RequestEcho)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestFlush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestFlush) */ {
 public:
  RequestFlush();
  virtual ~RequestFlush();

  RequestFlush(const RequestFlush& from);

  inline RequestFlush& operator=(const RequestFlush& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestFlush& default_instance();

  static inline const RequestFlush* internal_default_instance() {
    return reinterpret_cast<const RequestFlush*>(
               &_RequestFlush_default_instance_);
  }

  void Swap(RequestFlush* other);

  // implements Message ----------------------------------------------

  inline RequestFlush* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestFlush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestFlush& from);
  void MergeFrom(const RequestFlush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.RequestFlush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestInfo) */ {
 public:
  RequestInfo();
  virtual ~RequestInfo();

  RequestInfo(const RequestInfo& from);

  inline RequestInfo& operator=(const RequestInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInfo& default_instance();

  static inline const RequestInfo* internal_default_instance() {
    return reinterpret_cast<const RequestInfo*>(
               &_RequestInfo_default_instance_);
  }

  void Swap(RequestInfo* other);

  // implements Message ----------------------------------------------

  inline RequestInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInfo& from);
  void MergeFrom(const RequestInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // uint64 block_version = 2;
  void clear_block_version();
  static const int kBlockVersionFieldNumber = 2;
  ::google::protobuf::uint64 block_version() const;
  void set_block_version(::google::protobuf::uint64 value);

  // uint64 p2p_version = 3;
  void clear_p2p_version();
  static const int kP2PVersionFieldNumber = 3;
  ::google::protobuf::uint64 p2p_version() const;
  void set_p2p_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:types.RequestInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::uint64 block_version_;
  ::google::protobuf::uint64 p2p_version_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestSetOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestSetOption) */ {
 public:
  RequestSetOption();
  virtual ~RequestSetOption();

  RequestSetOption(const RequestSetOption& from);

  inline RequestSetOption& operator=(const RequestSetOption& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestSetOption& default_instance();

  static inline const RequestSetOption* internal_default_instance() {
    return reinterpret_cast<const RequestSetOption*>(
               &_RequestSetOption_default_instance_);
  }

  void Swap(RequestSetOption* other);

  // implements Message ----------------------------------------------

  inline RequestSetOption* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestSetOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestSetOption& from);
  void MergeFrom(const RequestSetOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:types.RequestSetOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestInitChain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestInitChain) */ {
 public:
  RequestInitChain();
  virtual ~RequestInitChain();

  RequestInitChain(const RequestInitChain& from);

  inline RequestInitChain& operator=(const RequestInitChain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestInitChain& default_instance();

  static inline const RequestInitChain* internal_default_instance() {
    return reinterpret_cast<const RequestInitChain*>(
               &_RequestInitChain_default_instance_);
  }

  void Swap(RequestInitChain* other);

  // implements Message ----------------------------------------------

  inline RequestInitChain* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestInitChain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestInitChain& from);
  void MergeFrom(const RequestInitChain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ValidatorUpdate validators = 4 [(.gogoproto.nullable) = false];
  int validators_size() const;
  void clear_validators();
  static const int kValidatorsFieldNumber = 4;
  const ::types::ValidatorUpdate& validators(int index) const;
  ::types::ValidatorUpdate* mutable_validators(int index);
  ::types::ValidatorUpdate* add_validators();
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
      mutable_validators();
  const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
      validators() const;

  // string chain_id = 2;
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // bytes app_state_bytes = 5;
  void clear_app_state_bytes();
  static const int kAppStateBytesFieldNumber = 5;
  const ::std::string& app_state_bytes() const;
  void set_app_state_bytes(const ::std::string& value);
  #if LANG_CXX11
  void set_app_state_bytes(::std::string&& value);
  #endif
  void set_app_state_bytes(const char* value);
  void set_app_state_bytes(const void* value, size_t size);
  ::std::string* mutable_app_state_bytes();
  ::std::string* release_app_state_bytes();
  void set_allocated_app_state_bytes(::std::string* app_state_bytes);

  // .google.protobuf.Timestamp time = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  const ::google::protobuf::Timestamp& time() const;
  ::google::protobuf::Timestamp* mutable_time();
  ::google::protobuf::Timestamp* release_time();
  void set_allocated_time(::google::protobuf::Timestamp* time);

  // .types.ConsensusParams consensus_params = 3;
  bool has_consensus_params() const;
  void clear_consensus_params();
  static const int kConsensusParamsFieldNumber = 3;
  const ::types::ConsensusParams& consensus_params() const;
  ::types::ConsensusParams* mutable_consensus_params();
  ::types::ConsensusParams* release_consensus_params();
  void set_allocated_consensus_params(::types::ConsensusParams* consensus_params);

  // @@protoc_insertion_point(class_scope:types.RequestInitChain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate > validators_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr app_state_bytes_;
  ::google::protobuf::Timestamp* time_;
  ::types::ConsensusParams* consensus_params_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestQuery) */ {
 public:
  RequestQuery();
  virtual ~RequestQuery();

  RequestQuery(const RequestQuery& from);

  inline RequestQuery& operator=(const RequestQuery& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestQuery& default_instance();

  static inline const RequestQuery* internal_default_instance() {
    return reinterpret_cast<const RequestQuery*>(
               &_RequestQuery_default_instance_);
  }

  void Swap(RequestQuery* other);

  // implements Message ----------------------------------------------

  inline RequestQuery* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestQuery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestQuery& from);
  void MergeFrom(const RequestQuery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string path = 2;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // bool prove = 4;
  void clear_prove();
  static const int kProveFieldNumber = 4;
  bool prove() const;
  void set_prove(bool value);

  // @@protoc_insertion_point(class_scope:types.RequestQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 height_;
  bool prove_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestBeginBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestBeginBlock) */ {
 public:
  RequestBeginBlock();
  virtual ~RequestBeginBlock();

  RequestBeginBlock(const RequestBeginBlock& from);

  inline RequestBeginBlock& operator=(const RequestBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestBeginBlock& default_instance();

  static inline const RequestBeginBlock* internal_default_instance() {
    return reinterpret_cast<const RequestBeginBlock*>(
               &_RequestBeginBlock_default_instance_);
  }

  void Swap(RequestBeginBlock* other);

  // implements Message ----------------------------------------------

  inline RequestBeginBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestBeginBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestBeginBlock& from);
  void MergeFrom(const RequestBeginBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Evidence byzantine_validators = 4 [(.gogoproto.nullable) = false];
  int byzantine_validators_size() const;
  void clear_byzantine_validators();
  static const int kByzantineValidatorsFieldNumber = 4;
  const ::types::Evidence& byzantine_validators(int index) const;
  ::types::Evidence* mutable_byzantine_validators(int index);
  ::types::Evidence* add_byzantine_validators();
  ::google::protobuf::RepeatedPtrField< ::types::Evidence >*
      mutable_byzantine_validators();
  const ::google::protobuf::RepeatedPtrField< ::types::Evidence >&
      byzantine_validators() const;

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .types.Header header = 2 [(.gogoproto.nullable) = false];
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 2;
  const ::types::Header& header() const;
  ::types::Header* mutable_header();
  ::types::Header* release_header();
  void set_allocated_header(::types::Header* header);

  // .types.LastCommitInfo last_commit_info = 3 [(.gogoproto.nullable) = false];
  bool has_last_commit_info() const;
  void clear_last_commit_info();
  static const int kLastCommitInfoFieldNumber = 3;
  const ::types::LastCommitInfo& last_commit_info() const;
  ::types::LastCommitInfo* mutable_last_commit_info();
  ::types::LastCommitInfo* release_last_commit_info();
  void set_allocated_last_commit_info(::types::LastCommitInfo* last_commit_info);

  // @@protoc_insertion_point(class_scope:types.RequestBeginBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::Evidence > byzantine_validators_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::types::Header* header_;
  ::types::LastCommitInfo* last_commit_info_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCheckTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestCheckTx) */ {
 public:
  RequestCheckTx();
  virtual ~RequestCheckTx();

  RequestCheckTx(const RequestCheckTx& from);

  inline RequestCheckTx& operator=(const RequestCheckTx& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCheckTx& default_instance();

  static inline const RequestCheckTx* internal_default_instance() {
    return reinterpret_cast<const RequestCheckTx*>(
               &_RequestCheckTx_default_instance_);
  }

  void Swap(RequestCheckTx* other);

  // implements Message ----------------------------------------------

  inline RequestCheckTx* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestCheckTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestCheckTx& from);
  void MergeFrom(const RequestCheckTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:types.RequestCheckTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestDeliverTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestDeliverTx) */ {
 public:
  RequestDeliverTx();
  virtual ~RequestDeliverTx();

  RequestDeliverTx(const RequestDeliverTx& from);

  inline RequestDeliverTx& operator=(const RequestDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestDeliverTx& default_instance();

  static inline const RequestDeliverTx* internal_default_instance() {
    return reinterpret_cast<const RequestDeliverTx*>(
               &_RequestDeliverTx_default_instance_);
  }

  void Swap(RequestDeliverTx* other);

  // implements Message ----------------------------------------------

  inline RequestDeliverTx* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestDeliverTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestDeliverTx& from);
  void MergeFrom(const RequestDeliverTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes tx = 1;
  void clear_tx();
  static const int kTxFieldNumber = 1;
  const ::std::string& tx() const;
  void set_tx(const ::std::string& value);
  #if LANG_CXX11
  void set_tx(::std::string&& value);
  #endif
  void set_tx(const char* value);
  void set_tx(const void* value, size_t size);
  ::std::string* mutable_tx();
  ::std::string* release_tx();
  void set_allocated_tx(::std::string* tx);

  // @@protoc_insertion_point(class_scope:types.RequestDeliverTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestEndBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestEndBlock) */ {
 public:
  RequestEndBlock();
  virtual ~RequestEndBlock();

  RequestEndBlock(const RequestEndBlock& from);

  inline RequestEndBlock& operator=(const RequestEndBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestEndBlock& default_instance();

  static inline const RequestEndBlock* internal_default_instance() {
    return reinterpret_cast<const RequestEndBlock*>(
               &_RequestEndBlock_default_instance_);
  }

  void Swap(RequestEndBlock* other);

  // implements Message ----------------------------------------------

  inline RequestEndBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestEndBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestEndBlock& from);
  void MergeFrom(const RequestEndBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.RequestEndBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 height_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestCommit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.RequestCommit) */ {
 public:
  RequestCommit();
  virtual ~RequestCommit();

  RequestCommit(const RequestCommit& from);

  inline RequestCommit& operator=(const RequestCommit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestCommit& default_instance();

  static inline const RequestCommit* internal_default_instance() {
    return reinterpret_cast<const RequestCommit*>(
               &_RequestCommit_default_instance_);
  }

  void Swap(RequestCommit* other);

  // implements Message ----------------------------------------------

  inline RequestCommit* New() const PROTOBUF_FINAL { return New(NULL); }

  RequestCommit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RequestCommit& from);
  void MergeFrom(const RequestCommit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RequestCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.RequestCommit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  enum ValueCase {
    kException = 1,
    kEcho = 2,
    kFlush = 3,
    kInfo = 4,
    kSetOption = 5,
    kInitChain = 6,
    kQuery = 7,
    kBeginBlock = 8,
    kCheckTx = 9,
    kDeliverTx = 10,
    kEndBlock = 11,
    kCommit = 12,
    VALUE_NOT_SET = 0,
  };

  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.ResponseException exception = 1;
  bool has_exception() const;
  void clear_exception();
  static const int kExceptionFieldNumber = 1;
  const ::types::ResponseException& exception() const;
  ::types::ResponseException* mutable_exception();
  ::types::ResponseException* release_exception();
  void set_allocated_exception(::types::ResponseException* exception);

  // .types.ResponseEcho echo = 2;
  bool has_echo() const;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::types::ResponseEcho& echo() const;
  ::types::ResponseEcho* mutable_echo();
  ::types::ResponseEcho* release_echo();
  void set_allocated_echo(::types::ResponseEcho* echo);

  // .types.ResponseFlush flush = 3;
  bool has_flush() const;
  void clear_flush();
  static const int kFlushFieldNumber = 3;
  const ::types::ResponseFlush& flush() const;
  ::types::ResponseFlush* mutable_flush();
  ::types::ResponseFlush* release_flush();
  void set_allocated_flush(::types::ResponseFlush* flush);

  // .types.ResponseInfo info = 4;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::types::ResponseInfo& info() const;
  ::types::ResponseInfo* mutable_info();
  ::types::ResponseInfo* release_info();
  void set_allocated_info(::types::ResponseInfo* info);

  // .types.ResponseSetOption set_option = 5;
  bool has_set_option() const;
  void clear_set_option();
  static const int kSetOptionFieldNumber = 5;
  const ::types::ResponseSetOption& set_option() const;
  ::types::ResponseSetOption* mutable_set_option();
  ::types::ResponseSetOption* release_set_option();
  void set_allocated_set_option(::types::ResponseSetOption* set_option);

  // .types.ResponseInitChain init_chain = 6;
  bool has_init_chain() const;
  void clear_init_chain();
  static const int kInitChainFieldNumber = 6;
  const ::types::ResponseInitChain& init_chain() const;
  ::types::ResponseInitChain* mutable_init_chain();
  ::types::ResponseInitChain* release_init_chain();
  void set_allocated_init_chain(::types::ResponseInitChain* init_chain);

  // .types.ResponseQuery query = 7;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 7;
  const ::types::ResponseQuery& query() const;
  ::types::ResponseQuery* mutable_query();
  ::types::ResponseQuery* release_query();
  void set_allocated_query(::types::ResponseQuery* query);

  // .types.ResponseBeginBlock begin_block = 8;
  bool has_begin_block() const;
  void clear_begin_block();
  static const int kBeginBlockFieldNumber = 8;
  const ::types::ResponseBeginBlock& begin_block() const;
  ::types::ResponseBeginBlock* mutable_begin_block();
  ::types::ResponseBeginBlock* release_begin_block();
  void set_allocated_begin_block(::types::ResponseBeginBlock* begin_block);

  // .types.ResponseCheckTx check_tx = 9;
  bool has_check_tx() const;
  void clear_check_tx();
  static const int kCheckTxFieldNumber = 9;
  const ::types::ResponseCheckTx& check_tx() const;
  ::types::ResponseCheckTx* mutable_check_tx();
  ::types::ResponseCheckTx* release_check_tx();
  void set_allocated_check_tx(::types::ResponseCheckTx* check_tx);

  // .types.ResponseDeliverTx deliver_tx = 10;
  bool has_deliver_tx() const;
  void clear_deliver_tx();
  static const int kDeliverTxFieldNumber = 10;
  const ::types::ResponseDeliverTx& deliver_tx() const;
  ::types::ResponseDeliverTx* mutable_deliver_tx();
  ::types::ResponseDeliverTx* release_deliver_tx();
  void set_allocated_deliver_tx(::types::ResponseDeliverTx* deliver_tx);

  // .types.ResponseEndBlock end_block = 11;
  bool has_end_block() const;
  void clear_end_block();
  static const int kEndBlockFieldNumber = 11;
  const ::types::ResponseEndBlock& end_block() const;
  ::types::ResponseEndBlock* mutable_end_block();
  ::types::ResponseEndBlock* release_end_block();
  void set_allocated_end_block(::types::ResponseEndBlock* end_block);

  // .types.ResponseCommit commit = 12;
  bool has_commit() const;
  void clear_commit();
  static const int kCommitFieldNumber = 12;
  const ::types::ResponseCommit& commit() const;
  ::types::ResponseCommit* mutable_commit();
  ::types::ResponseCommit* release_commit();
  void set_allocated_commit(::types::ResponseCommit* commit);

  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:types.Response)
 private:
  void set_has_exception();
  void set_has_echo();
  void set_has_flush();
  void set_has_info();
  void set_has_set_option();
  void set_has_init_chain();
  void set_has_query();
  void set_has_begin_block();
  void set_has_check_tx();
  void set_has_deliver_tx();
  void set_has_end_block();
  void set_has_commit();

  inline bool has_value() const;
  void clear_value();
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::types::ResponseException* exception_;
    ::types::ResponseEcho* echo_;
    ::types::ResponseFlush* flush_;
    ::types::ResponseInfo* info_;
    ::types::ResponseSetOption* set_option_;
    ::types::ResponseInitChain* init_chain_;
    ::types::ResponseQuery* query_;
    ::types::ResponseBeginBlock* begin_block_;
    ::types::ResponseCheckTx* check_tx_;
    ::types::ResponseDeliverTx* deliver_tx_;
    ::types::ResponseEndBlock* end_block_;
    ::types::ResponseCommit* commit_;
  } value_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseException : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseException) */ {
 public:
  ResponseException();
  virtual ~ResponseException();

  ResponseException(const ResponseException& from);

  inline ResponseException& operator=(const ResponseException& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseException& default_instance();

  static inline const ResponseException* internal_default_instance() {
    return reinterpret_cast<const ResponseException*>(
               &_ResponseException_default_instance_);
  }

  void Swap(ResponseException* other);

  // implements Message ----------------------------------------------

  inline ResponseException* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseException* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseException& from);
  void MergeFrom(const ResponseException& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseException* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error = 1;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::std::string& error() const;
  void set_error(const ::std::string& value);
  #if LANG_CXX11
  void set_error(::std::string&& value);
  #endif
  void set_error(const char* value);
  void set_error(const char* value, size_t size);
  ::std::string* mutable_error();
  ::std::string* release_error();
  void set_allocated_error(::std::string* error);

  // @@protoc_insertion_point(class_scope:types.ResponseException)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseEcho : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseEcho) */ {
 public:
  ResponseEcho();
  virtual ~ResponseEcho();

  ResponseEcho(const ResponseEcho& from);

  inline ResponseEcho& operator=(const ResponseEcho& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEcho& default_instance();

  static inline const ResponseEcho* internal_default_instance() {
    return reinterpret_cast<const ResponseEcho*>(
               &_ResponseEcho_default_instance_);
  }

  void Swap(ResponseEcho* other);

  // implements Message ----------------------------------------------

  inline ResponseEcho* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseEcho* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseEcho& from);
  void MergeFrom(const ResponseEcho& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseEcho* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:types.ResponseEcho)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseFlush : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseFlush) */ {
 public:
  ResponseFlush();
  virtual ~ResponseFlush();

  ResponseFlush(const ResponseFlush& from);

  inline ResponseFlush& operator=(const ResponseFlush& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseFlush& default_instance();

  static inline const ResponseFlush* internal_default_instance() {
    return reinterpret_cast<const ResponseFlush*>(
               &_ResponseFlush_default_instance_);
  }

  void Swap(ResponseFlush* other);

  // implements Message ----------------------------------------------

  inline ResponseFlush* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseFlush* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseFlush& from);
  void MergeFrom(const ResponseFlush& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseFlush* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:types.ResponseFlush)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseInfo) */ {
 public:
  ResponseInfo();
  virtual ~ResponseInfo();

  ResponseInfo(const ResponseInfo& from);

  inline ResponseInfo& operator=(const ResponseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseInfo& default_instance();

  static inline const ResponseInfo* internal_default_instance() {
    return reinterpret_cast<const ResponseInfo*>(
               &_ResponseInfo_default_instance_);
  }

  void Swap(ResponseInfo* other);

  // implements Message ----------------------------------------------

  inline ResponseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseInfo& from);
  void MergeFrom(const ResponseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bytes last_block_app_hash = 5;
  void clear_last_block_app_hash();
  static const int kLastBlockAppHashFieldNumber = 5;
  const ::std::string& last_block_app_hash() const;
  void set_last_block_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_block_app_hash(::std::string&& value);
  #endif
  void set_last_block_app_hash(const char* value);
  void set_last_block_app_hash(const void* value, size_t size);
  ::std::string* mutable_last_block_app_hash();
  ::std::string* release_last_block_app_hash();
  void set_allocated_last_block_app_hash(::std::string* last_block_app_hash);

  // uint64 app_version = 3;
  void clear_app_version();
  static const int kAppVersionFieldNumber = 3;
  ::google::protobuf::uint64 app_version() const;
  void set_app_version(::google::protobuf::uint64 value);

  // int64 last_block_height = 4;
  void clear_last_block_height();
  static const int kLastBlockHeightFieldNumber = 4;
  ::google::protobuf::int64 last_block_height() const;
  void set_last_block_height(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.ResponseInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr last_block_app_hash_;
  ::google::protobuf::uint64 app_version_;
  ::google::protobuf::int64 last_block_height_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseSetOption : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseSetOption) */ {
 public:
  ResponseSetOption();
  virtual ~ResponseSetOption();

  ResponseSetOption(const ResponseSetOption& from);

  inline ResponseSetOption& operator=(const ResponseSetOption& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseSetOption& default_instance();

  static inline const ResponseSetOption* internal_default_instance() {
    return reinterpret_cast<const ResponseSetOption*>(
               &_ResponseSetOption_default_instance_);
  }

  void Swap(ResponseSetOption* other);

  // implements Message ----------------------------------------------

  inline ResponseSetOption* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseSetOption* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseSetOption& from);
  void MergeFrom(const ResponseSetOption& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseSetOption* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseSetOption)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseInitChain : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseInitChain) */ {
 public:
  ResponseInitChain();
  virtual ~ResponseInitChain();

  ResponseInitChain(const ResponseInitChain& from);

  inline ResponseInitChain& operator=(const ResponseInitChain& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseInitChain& default_instance();

  static inline const ResponseInitChain* internal_default_instance() {
    return reinterpret_cast<const ResponseInitChain*>(
               &_ResponseInitChain_default_instance_);
  }

  void Swap(ResponseInitChain* other);

  // implements Message ----------------------------------------------

  inline ResponseInitChain* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseInitChain* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseInitChain& from);
  void MergeFrom(const ResponseInitChain& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseInitChain* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ValidatorUpdate validators = 2 [(.gogoproto.nullable) = false];
  int validators_size() const;
  void clear_validators();
  static const int kValidatorsFieldNumber = 2;
  const ::types::ValidatorUpdate& validators(int index) const;
  ::types::ValidatorUpdate* mutable_validators(int index);
  ::types::ValidatorUpdate* add_validators();
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
      mutable_validators();
  const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
      validators() const;

  // .types.ConsensusParams consensus_params = 1;
  bool has_consensus_params() const;
  void clear_consensus_params();
  static const int kConsensusParamsFieldNumber = 1;
  const ::types::ConsensusParams& consensus_params() const;
  ::types::ConsensusParams* mutable_consensus_params();
  ::types::ConsensusParams* release_consensus_params();
  void set_allocated_consensus_params(::types::ConsensusParams* consensus_params);

  // @@protoc_insertion_point(class_scope:types.ResponseInitChain)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate > validators_;
  ::types::ConsensusParams* consensus_params_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseQuery : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseQuery) */ {
 public:
  ResponseQuery();
  virtual ~ResponseQuery();

  ResponseQuery(const ResponseQuery& from);

  inline ResponseQuery& operator=(const ResponseQuery& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseQuery& default_instance();

  static inline const ResponseQuery* internal_default_instance() {
    return reinterpret_cast<const ResponseQuery*>(
               &_ResponseQuery_default_instance_);
  }

  void Swap(ResponseQuery* other);

  // implements Message ----------------------------------------------

  inline ResponseQuery* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseQuery* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseQuery& from);
  void MergeFrom(const ResponseQuery& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // bytes key = 6;
  void clear_key();
  static const int kKeyFieldNumber = 6;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const void* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 7;
  void clear_value();
  static const int kValueFieldNumber = 7;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // string codespace = 10;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 10;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // .merkle.Proof proof = 8;
  bool has_proof() const;
  void clear_proof();
  static const int kProofFieldNumber = 8;
  const ::merkle::Proof& proof() const;
  ::merkle::Proof* mutable_proof();
  ::merkle::Proof* release_proof();
  void set_allocated_proof(::merkle::Proof* proof);

  // int64 index = 5;
  void clear_index();
  static const int kIndexFieldNumber = 5;
  ::google::protobuf::int64 index() const;
  void set_index(::google::protobuf::int64 value);

  // int64 height = 9;
  void clear_height();
  static const int kHeightFieldNumber = 9;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseQuery)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::merkle::Proof* proof_;
  ::google::protobuf::int64 index_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseBeginBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseBeginBlock) */ {
 public:
  ResponseBeginBlock();
  virtual ~ResponseBeginBlock();

  ResponseBeginBlock(const ResponseBeginBlock& from);

  inline ResponseBeginBlock& operator=(const ResponseBeginBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseBeginBlock& default_instance();

  static inline const ResponseBeginBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseBeginBlock*>(
               &_ResponseBeginBlock_default_instance_);
  }

  void Swap(ResponseBeginBlock* other);

  // implements Message ----------------------------------------------

  inline ResponseBeginBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseBeginBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseBeginBlock& from);
  void MergeFrom(const ResponseBeginBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseBeginBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.KVPair tags = 1 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 1;
  const ::common::KVPair& tags(int index) const;
  ::common::KVPair* mutable_tags(int index);
  ::common::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
      tags() const;

  // @@protoc_insertion_point(class_scope:types.ResponseBeginBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::KVPair > tags_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseCheckTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseCheckTx) */ {
 public:
  ResponseCheckTx();
  virtual ~ResponseCheckTx();

  ResponseCheckTx(const ResponseCheckTx& from);

  inline ResponseCheckTx& operator=(const ResponseCheckTx& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCheckTx& default_instance();

  static inline const ResponseCheckTx* internal_default_instance() {
    return reinterpret_cast<const ResponseCheckTx*>(
               &_ResponseCheckTx_default_instance_);
  }

  void Swap(ResponseCheckTx* other);

  // implements Message ----------------------------------------------

  inline ResponseCheckTx* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseCheckTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseCheckTx& from);
  void MergeFrom(const ResponseCheckTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseCheckTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.KVPair tags = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::common::KVPair& tags(int index) const;
  ::common::KVPair* mutable_tags(int index);
  ::common::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // string codespace = 8;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 8;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseCheckTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseDeliverTx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseDeliverTx) */ {
 public:
  ResponseDeliverTx();
  virtual ~ResponseDeliverTx();

  ResponseDeliverTx(const ResponseDeliverTx& from);

  inline ResponseDeliverTx& operator=(const ResponseDeliverTx& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseDeliverTx& default_instance();

  static inline const ResponseDeliverTx* internal_default_instance() {
    return reinterpret_cast<const ResponseDeliverTx*>(
               &_ResponseDeliverTx_default_instance_);
  }

  void Swap(ResponseDeliverTx* other);

  // implements Message ----------------------------------------------

  inline ResponseDeliverTx* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseDeliverTx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseDeliverTx& from);
  void MergeFrom(const ResponseDeliverTx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseDeliverTx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .common.KVPair tags = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 7;
  const ::common::KVPair& tags(int index) const;
  ::common::KVPair* mutable_tags(int index);
  ::common::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
      tags() const;

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // string log = 3;
  void clear_log();
  static const int kLogFieldNumber = 3;
  const ::std::string& log() const;
  void set_log(const ::std::string& value);
  #if LANG_CXX11
  void set_log(::std::string&& value);
  #endif
  void set_log(const char* value);
  void set_log(const char* value, size_t size);
  ::std::string* mutable_log();
  ::std::string* release_log();
  void set_allocated_log(::std::string* log);

  // string info = 4;
  void clear_info();
  static const int kInfoFieldNumber = 4;
  const ::std::string& info() const;
  void set_info(const ::std::string& value);
  #if LANG_CXX11
  void set_info(::std::string&& value);
  #endif
  void set_info(const char* value);
  void set_info(const char* value, size_t size);
  ::std::string* mutable_info();
  ::std::string* release_info();
  void set_allocated_info(::std::string* info);

  // string codespace = 8;
  void clear_codespace();
  static const int kCodespaceFieldNumber = 8;
  const ::std::string& codespace() const;
  void set_codespace(const ::std::string& value);
  #if LANG_CXX11
  void set_codespace(::std::string&& value);
  #endif
  void set_codespace(const char* value);
  void set_codespace(const char* value, size_t size);
  ::std::string* mutable_codespace();
  ::std::string* release_codespace();
  void set_allocated_codespace(::std::string* codespace);

  // int64 gas_wanted = 5;
  void clear_gas_wanted();
  static const int kGasWantedFieldNumber = 5;
  ::google::protobuf::int64 gas_wanted() const;
  void set_gas_wanted(::google::protobuf::int64 value);

  // int64 gas_used = 6;
  void clear_gas_used();
  static const int kGasUsedFieldNumber = 6;
  ::google::protobuf::int64 gas_used() const;
  void set_gas_used(::google::protobuf::int64 value);

  // uint32 code = 1;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::uint32 code() const;
  void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:types.ResponseDeliverTx)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::common::KVPair > tags_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr log_;
  ::google::protobuf::internal::ArenaStringPtr info_;
  ::google::protobuf::internal::ArenaStringPtr codespace_;
  ::google::protobuf::int64 gas_wanted_;
  ::google::protobuf::int64 gas_used_;
  ::google::protobuf::uint32 code_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseEndBlock : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseEndBlock) */ {
 public:
  ResponseEndBlock();
  virtual ~ResponseEndBlock();

  ResponseEndBlock(const ResponseEndBlock& from);

  inline ResponseEndBlock& operator=(const ResponseEndBlock& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseEndBlock& default_instance();

  static inline const ResponseEndBlock* internal_default_instance() {
    return reinterpret_cast<const ResponseEndBlock*>(
               &_ResponseEndBlock_default_instance_);
  }

  void Swap(ResponseEndBlock* other);

  // implements Message ----------------------------------------------

  inline ResponseEndBlock* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseEndBlock* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseEndBlock& from);
  void MergeFrom(const ResponseEndBlock& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseEndBlock* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ValidatorUpdate validator_updates = 1 [(.gogoproto.nullable) = false];
  int validator_updates_size() const;
  void clear_validator_updates();
  static const int kValidatorUpdatesFieldNumber = 1;
  const ::types::ValidatorUpdate& validator_updates(int index) const;
  ::types::ValidatorUpdate* mutable_validator_updates(int index);
  ::types::ValidatorUpdate* add_validator_updates();
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
      mutable_validator_updates();
  const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
      validator_updates() const;

  // repeated .common.KVPair tags = 3 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::common::KVPair& tags(int index) const;
  ::common::KVPair* mutable_tags(int index);
  ::common::KVPair* add_tags();
  ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
      mutable_tags();
  const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
      tags() const;

  // .types.ConsensusParams consensus_param_updates = 2;
  bool has_consensus_param_updates() const;
  void clear_consensus_param_updates();
  static const int kConsensusParamUpdatesFieldNumber = 2;
  const ::types::ConsensusParams& consensus_param_updates() const;
  ::types::ConsensusParams* mutable_consensus_param_updates();
  ::types::ConsensusParams* release_consensus_param_updates();
  void set_allocated_consensus_param_updates(::types::ConsensusParams* consensus_param_updates);

  // @@protoc_insertion_point(class_scope:types.ResponseEndBlock)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate > validator_updates_;
  ::google::protobuf::RepeatedPtrField< ::common::KVPair > tags_;
  ::types::ConsensusParams* consensus_param_updates_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseCommit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ResponseCommit) */ {
 public:
  ResponseCommit();
  virtual ~ResponseCommit();

  ResponseCommit(const ResponseCommit& from);

  inline ResponseCommit& operator=(const ResponseCommit& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseCommit& default_instance();

  static inline const ResponseCommit* internal_default_instance() {
    return reinterpret_cast<const ResponseCommit*>(
               &_ResponseCommit_default_instance_);
  }

  void Swap(ResponseCommit* other);

  // implements Message ----------------------------------------------

  inline ResponseCommit* New() const PROTOBUF_FINAL { return New(NULL); }

  ResponseCommit* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResponseCommit& from);
  void MergeFrom(const ResponseCommit& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResponseCommit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:types.ResponseCommit)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConsensusParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ConsensusParams) */ {
 public:
  ConsensusParams();
  virtual ~ConsensusParams();

  ConsensusParams(const ConsensusParams& from);

  inline ConsensusParams& operator=(const ConsensusParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConsensusParams& default_instance();

  static inline const ConsensusParams* internal_default_instance() {
    return reinterpret_cast<const ConsensusParams*>(
               &_ConsensusParams_default_instance_);
  }

  void Swap(ConsensusParams* other);

  // implements Message ----------------------------------------------

  inline ConsensusParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ConsensusParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConsensusParams& from);
  void MergeFrom(const ConsensusParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConsensusParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.BlockSizeParams block_size = 1;
  bool has_block_size() const;
  void clear_block_size();
  static const int kBlockSizeFieldNumber = 1;
  const ::types::BlockSizeParams& block_size() const;
  ::types::BlockSizeParams* mutable_block_size();
  ::types::BlockSizeParams* release_block_size();
  void set_allocated_block_size(::types::BlockSizeParams* block_size);

  // .types.EvidenceParams evidence = 2;
  bool has_evidence() const;
  void clear_evidence();
  static const int kEvidenceFieldNumber = 2;
  const ::types::EvidenceParams& evidence() const;
  ::types::EvidenceParams* mutable_evidence();
  ::types::EvidenceParams* release_evidence();
  void set_allocated_evidence(::types::EvidenceParams* evidence);

  // .types.ValidatorParams validator = 3;
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 3;
  const ::types::ValidatorParams& validator() const;
  ::types::ValidatorParams* mutable_validator();
  ::types::ValidatorParams* release_validator();
  void set_allocated_validator(::types::ValidatorParams* validator);

  // @@protoc_insertion_point(class_scope:types.ConsensusParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::BlockSizeParams* block_size_;
  ::types::EvidenceParams* evidence_;
  ::types::ValidatorParams* validator_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockSizeParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BlockSizeParams) */ {
 public:
  BlockSizeParams();
  virtual ~BlockSizeParams();

  BlockSizeParams(const BlockSizeParams& from);

  inline BlockSizeParams& operator=(const BlockSizeParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockSizeParams& default_instance();

  static inline const BlockSizeParams* internal_default_instance() {
    return reinterpret_cast<const BlockSizeParams*>(
               &_BlockSizeParams_default_instance_);
  }

  void Swap(BlockSizeParams* other);

  // implements Message ----------------------------------------------

  inline BlockSizeParams* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockSizeParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockSizeParams& from);
  void MergeFrom(const BlockSizeParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockSizeParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 max_bytes = 1;
  void clear_max_bytes();
  static const int kMaxBytesFieldNumber = 1;
  ::google::protobuf::int64 max_bytes() const;
  void set_max_bytes(::google::protobuf::int64 value);

  // int64 max_gas = 2;
  void clear_max_gas();
  static const int kMaxGasFieldNumber = 2;
  ::google::protobuf::int64 max_gas() const;
  void set_max_gas(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.BlockSizeParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 max_bytes_;
  ::google::protobuf::int64 max_gas_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EvidenceParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.EvidenceParams) */ {
 public:
  EvidenceParams();
  virtual ~EvidenceParams();

  EvidenceParams(const EvidenceParams& from);

  inline EvidenceParams& operator=(const EvidenceParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EvidenceParams& default_instance();

  static inline const EvidenceParams* internal_default_instance() {
    return reinterpret_cast<const EvidenceParams*>(
               &_EvidenceParams_default_instance_);
  }

  void Swap(EvidenceParams* other);

  // implements Message ----------------------------------------------

  inline EvidenceParams* New() const PROTOBUF_FINAL { return New(NULL); }

  EvidenceParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EvidenceParams& from);
  void MergeFrom(const EvidenceParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EvidenceParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 max_age = 1;
  void clear_max_age();
  static const int kMaxAgeFieldNumber = 1;
  ::google::protobuf::int64 max_age() const;
  void set_max_age(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.EvidenceParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 max_age_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValidatorParams : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ValidatorParams) */ {
 public:
  ValidatorParams();
  virtual ~ValidatorParams();

  ValidatorParams(const ValidatorParams& from);

  inline ValidatorParams& operator=(const ValidatorParams& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidatorParams& default_instance();

  static inline const ValidatorParams* internal_default_instance() {
    return reinterpret_cast<const ValidatorParams*>(
               &_ValidatorParams_default_instance_);
  }

  void Swap(ValidatorParams* other);

  // implements Message ----------------------------------------------

  inline ValidatorParams* New() const PROTOBUF_FINAL { return New(NULL); }

  ValidatorParams* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ValidatorParams& from);
  void MergeFrom(const ValidatorParams& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ValidatorParams* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string pub_key_types = 1;
  int pub_key_types_size() const;
  void clear_pub_key_types();
  static const int kPubKeyTypesFieldNumber = 1;
  const ::std::string& pub_key_types(int index) const;
  ::std::string* mutable_pub_key_types(int index);
  void set_pub_key_types(int index, const ::std::string& value);
  void set_pub_key_types(int index, const char* value);
  void set_pub_key_types(int index, const char* value, size_t size);
  ::std::string* add_pub_key_types();
  void add_pub_key_types(const ::std::string& value);
  void add_pub_key_types(const char* value);
  void add_pub_key_types(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& pub_key_types() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_pub_key_types();

  // @@protoc_insertion_point(class_scope:types.ValidatorParams)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> pub_key_types_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LastCommitInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.LastCommitInfo) */ {
 public:
  LastCommitInfo();
  virtual ~LastCommitInfo();

  LastCommitInfo(const LastCommitInfo& from);

  inline LastCommitInfo& operator=(const LastCommitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LastCommitInfo& default_instance();

  static inline const LastCommitInfo* internal_default_instance() {
    return reinterpret_cast<const LastCommitInfo*>(
               &_LastCommitInfo_default_instance_);
  }

  void Swap(LastCommitInfo* other);

  // implements Message ----------------------------------------------

  inline LastCommitInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  LastCommitInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LastCommitInfo& from);
  void MergeFrom(const LastCommitInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LastCommitInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.VoteInfo votes = 2 [(.gogoproto.nullable) = false];
  int votes_size() const;
  void clear_votes();
  static const int kVotesFieldNumber = 2;
  const ::types::VoteInfo& votes(int index) const;
  ::types::VoteInfo* mutable_votes(int index);
  ::types::VoteInfo* add_votes();
  ::google::protobuf::RepeatedPtrField< ::types::VoteInfo >*
      mutable_votes();
  const ::google::protobuf::RepeatedPtrField< ::types::VoteInfo >&
      votes() const;

  // int32 round = 1;
  void clear_round();
  static const int kRoundFieldNumber = 1;
  ::google::protobuf::int32 round() const;
  void set_round(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.LastCommitInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::types::VoteInfo > votes_;
  ::google::protobuf::int32 round_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  inline Header* New() const PROTOBUF_FINAL { return New(NULL); }

  Header* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string chain_id = 2 [(.gogoproto.customname) = "ChainID"];
  void clear_chain_id();
  static const int kChainIdFieldNumber = 2;
  const ::std::string& chain_id() const;
  void set_chain_id(const ::std::string& value);
  #if LANG_CXX11
  void set_chain_id(::std::string&& value);
  #endif
  void set_chain_id(const char* value);
  void set_chain_id(const char* value, size_t size);
  ::std::string* mutable_chain_id();
  ::std::string* release_chain_id();
  void set_allocated_chain_id(::std::string* chain_id);

  // bytes last_commit_hash = 8;
  void clear_last_commit_hash();
  static const int kLastCommitHashFieldNumber = 8;
  const ::std::string& last_commit_hash() const;
  void set_last_commit_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_commit_hash(::std::string&& value);
  #endif
  void set_last_commit_hash(const char* value);
  void set_last_commit_hash(const void* value, size_t size);
  ::std::string* mutable_last_commit_hash();
  ::std::string* release_last_commit_hash();
  void set_allocated_last_commit_hash(::std::string* last_commit_hash);

  // bytes data_hash = 9;
  void clear_data_hash();
  static const int kDataHashFieldNumber = 9;
  const ::std::string& data_hash() const;
  void set_data_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_data_hash(::std::string&& value);
  #endif
  void set_data_hash(const char* value);
  void set_data_hash(const void* value, size_t size);
  ::std::string* mutable_data_hash();
  ::std::string* release_data_hash();
  void set_allocated_data_hash(::std::string* data_hash);

  // bytes validators_hash = 10;
  void clear_validators_hash();
  static const int kValidatorsHashFieldNumber = 10;
  const ::std::string& validators_hash() const;
  void set_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_validators_hash(::std::string&& value);
  #endif
  void set_validators_hash(const char* value);
  void set_validators_hash(const void* value, size_t size);
  ::std::string* mutable_validators_hash();
  ::std::string* release_validators_hash();
  void set_allocated_validators_hash(::std::string* validators_hash);

  // bytes next_validators_hash = 11;
  void clear_next_validators_hash();
  static const int kNextValidatorsHashFieldNumber = 11;
  const ::std::string& next_validators_hash() const;
  void set_next_validators_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_next_validators_hash(::std::string&& value);
  #endif
  void set_next_validators_hash(const char* value);
  void set_next_validators_hash(const void* value, size_t size);
  ::std::string* mutable_next_validators_hash();
  ::std::string* release_next_validators_hash();
  void set_allocated_next_validators_hash(::std::string* next_validators_hash);

  // bytes consensus_hash = 12;
  void clear_consensus_hash();
  static const int kConsensusHashFieldNumber = 12;
  const ::std::string& consensus_hash() const;
  void set_consensus_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_consensus_hash(::std::string&& value);
  #endif
  void set_consensus_hash(const char* value);
  void set_consensus_hash(const void* value, size_t size);
  ::std::string* mutable_consensus_hash();
  ::std::string* release_consensus_hash();
  void set_allocated_consensus_hash(::std::string* consensus_hash);

  // bytes app_hash = 13;
  void clear_app_hash();
  static const int kAppHashFieldNumber = 13;
  const ::std::string& app_hash() const;
  void set_app_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_app_hash(::std::string&& value);
  #endif
  void set_app_hash(const char* value);
  void set_app_hash(const void* value, size_t size);
  ::std::string* mutable_app_hash();
  ::std::string* release_app_hash();
  void set_allocated_app_hash(::std::string* app_hash);

  // bytes last_results_hash = 14;
  void clear_last_results_hash();
  static const int kLastResultsHashFieldNumber = 14;
  const ::std::string& last_results_hash() const;
  void set_last_results_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_last_results_hash(::std::string&& value);
  #endif
  void set_last_results_hash(const char* value);
  void set_last_results_hash(const void* value, size_t size);
  ::std::string* mutable_last_results_hash();
  ::std::string* release_last_results_hash();
  void set_allocated_last_results_hash(::std::string* last_results_hash);

  // bytes evidence_hash = 15;
  void clear_evidence_hash();
  static const int kEvidenceHashFieldNumber = 15;
  const ::std::string& evidence_hash() const;
  void set_evidence_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_evidence_hash(::std::string&& value);
  #endif
  void set_evidence_hash(const char* value);
  void set_evidence_hash(const void* value, size_t size);
  ::std::string* mutable_evidence_hash();
  ::std::string* release_evidence_hash();
  void set_allocated_evidence_hash(::std::string* evidence_hash);

  // bytes proposer_address = 16;
  void clear_proposer_address();
  static const int kProposerAddressFieldNumber = 16;
  const ::std::string& proposer_address() const;
  void set_proposer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_proposer_address(::std::string&& value);
  #endif
  void set_proposer_address(const char* value);
  void set_proposer_address(const void* value, size_t size);
  ::std::string* mutable_proposer_address();
  ::std::string* release_proposer_address();
  void set_allocated_proposer_address(::std::string* proposer_address);

  // .types.Version version = 1 [(.gogoproto.nullable) = false];
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::types::Version& version() const;
  ::types::Version* mutable_version();
  ::types::Version* release_version();
  void set_allocated_version(::types::Version* version);

  // .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  const ::google::protobuf::Timestamp& time() const;
  ::google::protobuf::Timestamp* mutable_time();
  ::google::protobuf::Timestamp* release_time();
  void set_allocated_time(::google::protobuf::Timestamp* time);

  // .types.BlockID last_block_id = 7 [(.gogoproto.nullable) = false];
  bool has_last_block_id() const;
  void clear_last_block_id();
  static const int kLastBlockIdFieldNumber = 7;
  const ::types::BlockID& last_block_id() const;
  ::types::BlockID* mutable_last_block_id();
  ::types::BlockID* release_last_block_id();
  void set_allocated_last_block_id(::types::BlockID* last_block_id);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 num_txs = 5;
  void clear_num_txs();
  static const int kNumTxsFieldNumber = 5;
  ::google::protobuf::int64 num_txs() const;
  void set_num_txs(::google::protobuf::int64 value);

  // int64 total_txs = 6;
  void clear_total_txs();
  static const int kTotalTxsFieldNumber = 6;
  ::google::protobuf::int64 total_txs() const;
  void set_total_txs(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr chain_id_;
  ::google::protobuf::internal::ArenaStringPtr last_commit_hash_;
  ::google::protobuf::internal::ArenaStringPtr data_hash_;
  ::google::protobuf::internal::ArenaStringPtr validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr next_validators_hash_;
  ::google::protobuf::internal::ArenaStringPtr consensus_hash_;
  ::google::protobuf::internal::ArenaStringPtr app_hash_;
  ::google::protobuf::internal::ArenaStringPtr last_results_hash_;
  ::google::protobuf::internal::ArenaStringPtr evidence_hash_;
  ::google::protobuf::internal::ArenaStringPtr proposer_address_;
  ::types::Version* version_;
  ::google::protobuf::Timestamp* time_;
  ::types::BlockID* last_block_id_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 num_txs_;
  ::google::protobuf::int64 total_txs_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Version : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Version) */ {
 public:
  Version();
  virtual ~Version();

  Version(const Version& from);

  inline Version& operator=(const Version& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Version& default_instance();

  static inline const Version* internal_default_instance() {
    return reinterpret_cast<const Version*>(
               &_Version_default_instance_);
  }

  void Swap(Version* other);

  // implements Message ----------------------------------------------

  inline Version* New() const PROTOBUF_FINAL { return New(NULL); }

  Version* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Version& from);
  void MergeFrom(const Version& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Version* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 Block = 1;
  void clear_block();
  static const int kBlockFieldNumber = 1;
  ::google::protobuf::uint64 block() const;
  void set_block(::google::protobuf::uint64 value);

  // uint64 App = 2;
  void clear_app();
  static const int kAppFieldNumber = 2;
  ::google::protobuf::uint64 app() const;
  void set_app(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:types.Version)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 block_;
  ::google::protobuf::uint64 app_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BlockID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BlockID) */ {
 public:
  BlockID();
  virtual ~BlockID();

  BlockID(const BlockID& from);

  inline BlockID& operator=(const BlockID& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlockID& default_instance();

  static inline const BlockID* internal_default_instance() {
    return reinterpret_cast<const BlockID*>(
               &_BlockID_default_instance_);
  }

  void Swap(BlockID* other);

  // implements Message ----------------------------------------------

  inline BlockID* New() const PROTOBUF_FINAL { return New(NULL); }

  BlockID* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BlockID& from);
  void MergeFrom(const BlockID& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BlockID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 1;
  void clear_hash();
  static const int kHashFieldNumber = 1;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // .types.PartSetHeader parts_header = 2 [(.gogoproto.nullable) = false];
  bool has_parts_header() const;
  void clear_parts_header();
  static const int kPartsHeaderFieldNumber = 2;
  const ::types::PartSetHeader& parts_header() const;
  ::types::PartSetHeader* mutable_parts_header();
  ::types::PartSetHeader* release_parts_header();
  void set_allocated_parts_header(::types::PartSetHeader* parts_header);

  // @@protoc_insertion_point(class_scope:types.BlockID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::types::PartSetHeader* parts_header_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartSetHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.PartSetHeader) */ {
 public:
  PartSetHeader();
  virtual ~PartSetHeader();

  PartSetHeader(const PartSetHeader& from);

  inline PartSetHeader& operator=(const PartSetHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartSetHeader& default_instance();

  static inline const PartSetHeader* internal_default_instance() {
    return reinterpret_cast<const PartSetHeader*>(
               &_PartSetHeader_default_instance_);
  }

  void Swap(PartSetHeader* other);

  // implements Message ----------------------------------------------

  inline PartSetHeader* New() const PROTOBUF_FINAL { return New(NULL); }

  PartSetHeader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartSetHeader& from);
  void MergeFrom(const PartSetHeader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartSetHeader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes hash = 2;
  void clear_hash();
  static const int kHashFieldNumber = 2;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // int32 total = 1;
  void clear_total();
  static const int kTotalFieldNumber = 1;
  ::google::protobuf::int32 total() const;
  void set_total(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.PartSetHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::int32 total_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Validator : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Validator) */ {
 public:
  Validator();
  virtual ~Validator();

  Validator(const Validator& from);

  inline Validator& operator=(const Validator& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Validator& default_instance();

  static inline const Validator* internal_default_instance() {
    return reinterpret_cast<const Validator*>(
               &_Validator_default_instance_);
  }

  void Swap(Validator* other);

  // implements Message ----------------------------------------------

  inline Validator* New() const PROTOBUF_FINAL { return New(NULL); }

  Validator* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Validator& from);
  void MergeFrom(const Validator& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Validator* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // int64 power = 3;
  void clear_power();
  static const int kPowerFieldNumber = 3;
  ::google::protobuf::int64 power() const;
  void set_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.Validator)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::int64 power_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ValidatorUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ValidatorUpdate) */ {
 public:
  ValidatorUpdate();
  virtual ~ValidatorUpdate();

  ValidatorUpdate(const ValidatorUpdate& from);

  inline ValidatorUpdate& operator=(const ValidatorUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ValidatorUpdate& default_instance();

  static inline const ValidatorUpdate* internal_default_instance() {
    return reinterpret_cast<const ValidatorUpdate*>(
               &_ValidatorUpdate_default_instance_);
  }

  void Swap(ValidatorUpdate* other);

  // implements Message ----------------------------------------------

  inline ValidatorUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  ValidatorUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ValidatorUpdate& from);
  void MergeFrom(const ValidatorUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ValidatorUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.PubKey pub_key = 1 [(.gogoproto.nullable) = false];
  bool has_pub_key() const;
  void clear_pub_key();
  static const int kPubKeyFieldNumber = 1;
  const ::types::PubKey& pub_key() const;
  ::types::PubKey* mutable_pub_key();
  ::types::PubKey* release_pub_key();
  void set_allocated_pub_key(::types::PubKey* pub_key);

  // int64 power = 2;
  void clear_power();
  static const int kPowerFieldNumber = 2;
  ::google::protobuf::int64 power() const;
  void set_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.ValidatorUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::PubKey* pub_key_;
  ::google::protobuf::int64 power_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VoteInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.VoteInfo) */ {
 public:
  VoteInfo();
  virtual ~VoteInfo();

  VoteInfo(const VoteInfo& from);

  inline VoteInfo& operator=(const VoteInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoteInfo& default_instance();

  static inline const VoteInfo* internal_default_instance() {
    return reinterpret_cast<const VoteInfo*>(
               &_VoteInfo_default_instance_);
  }

  void Swap(VoteInfo* other);

  // implements Message ----------------------------------------------

  inline VoteInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  VoteInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const VoteInfo& from);
  void MergeFrom(const VoteInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(VoteInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .types.Validator validator = 1 [(.gogoproto.nullable) = false];
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 1;
  const ::types::Validator& validator() const;
  ::types::Validator* mutable_validator();
  ::types::Validator* release_validator();
  void set_allocated_validator(::types::Validator* validator);

  // bool signed_last_block = 2;
  void clear_signed_last_block();
  static const int kSignedLastBlockFieldNumber = 2;
  bool signed_last_block() const;
  void set_signed_last_block(bool value);

  // @@protoc_insertion_point(class_scope:types.VoteInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::types::Validator* validator_;
  bool signed_last_block_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PubKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.PubKey) */ {
 public:
  PubKey();
  virtual ~PubKey();

  PubKey(const PubKey& from);

  inline PubKey& operator=(const PubKey& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PubKey& default_instance();

  static inline const PubKey* internal_default_instance() {
    return reinterpret_cast<const PubKey*>(
               &_PubKey_default_instance_);
  }

  void Swap(PubKey* other);

  // implements Message ----------------------------------------------

  inline PubKey* New() const PROTOBUF_FINAL { return New(NULL); }

  PubKey* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PubKey& from);
  void MergeFrom(const PubKey& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PubKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // bytes data = 2;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:types.PubKey)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Evidence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Evidence) */ {
 public:
  Evidence();
  virtual ~Evidence();

  Evidence(const Evidence& from);

  inline Evidence& operator=(const Evidence& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Evidence& default_instance();

  static inline const Evidence* internal_default_instance() {
    return reinterpret_cast<const Evidence*>(
               &_Evidence_default_instance_);
  }

  void Swap(Evidence* other);

  // implements Message ----------------------------------------------

  inline Evidence* New() const PROTOBUF_FINAL { return New(NULL); }

  Evidence* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Evidence& from);
  void MergeFrom(const Evidence& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Evidence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .types.Validator validator = 2 [(.gogoproto.nullable) = false];
  bool has_validator() const;
  void clear_validator();
  static const int kValidatorFieldNumber = 2;
  const ::types::Validator& validator() const;
  ::types::Validator* mutable_validator();
  ::types::Validator* release_validator();
  void set_allocated_validator(::types::Validator* validator);

  // .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  const ::google::protobuf::Timestamp& time() const;
  ::google::protobuf::Timestamp* mutable_time();
  ::google::protobuf::Timestamp* release_time();
  void set_allocated_time(::google::protobuf::Timestamp* time);

  // int64 height = 3;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  ::google::protobuf::int64 height() const;
  void set_height(::google::protobuf::int64 value);

  // int64 total_voting_power = 5;
  void clear_total_voting_power();
  static const int kTotalVotingPowerFieldNumber = 5;
  ::google::protobuf::int64 total_voting_power() const;
  void set_total_voting_power(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.Evidence)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::types::Validator* validator_;
  ::google::protobuf::Timestamp* time_;
  ::google::protobuf::int64 height_;
  ::google::protobuf::int64 total_voting_power_;
  mutable int _cached_size_;
  friend struct  protobuf_types_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// .types.RequestEcho echo = 2;
inline bool Request::has_echo() const {
  return value_case() == kEcho;
}
inline void Request::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Request::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline  const ::types::RequestEcho& Request::echo() const {
  // @@protoc_insertion_point(field_get:types.Request.echo)
  return has_echo()
      ? *value_.echo_
      : ::types::RequestEcho::default_instance();
}
inline ::types::RequestEcho* Request::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = new ::types::RequestEcho;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.echo)
  return value_.echo_;
}
inline ::types::RequestEcho* Request::release_echo() {
  // @@protoc_insertion_point(field_release:types.Request.echo)
  if (has_echo()) {
    clear_has_value();
    ::types::RequestEcho* temp = value_.echo_;
    value_.echo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_echo(::types::RequestEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.echo)
}

// .types.RequestFlush flush = 3;
inline bool Request::has_flush() const {
  return value_case() == kFlush;
}
inline void Request::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Request::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline  const ::types::RequestFlush& Request::flush() const {
  // @@protoc_insertion_point(field_get:types.Request.flush)
  return has_flush()
      ? *value_.flush_
      : ::types::RequestFlush::default_instance();
}
inline ::types::RequestFlush* Request::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = new ::types::RequestFlush;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.flush)
  return value_.flush_;
}
inline ::types::RequestFlush* Request::release_flush() {
  // @@protoc_insertion_point(field_release:types.Request.flush)
  if (has_flush()) {
    clear_has_value();
    ::types::RequestFlush* temp = value_.flush_;
    value_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_flush(::types::RequestFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.flush)
}

// .types.RequestInfo info = 4;
inline bool Request::has_info() const {
  return value_case() == kInfo;
}
inline void Request::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Request::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline  const ::types::RequestInfo& Request::info() const {
  // @@protoc_insertion_point(field_get:types.Request.info)
  return has_info()
      ? *value_.info_
      : ::types::RequestInfo::default_instance();
}
inline ::types::RequestInfo* Request::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = new ::types::RequestInfo;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.info)
  return value_.info_;
}
inline ::types::RequestInfo* Request::release_info() {
  // @@protoc_insertion_point(field_release:types.Request.info)
  if (has_info()) {
    clear_has_value();
    ::types::RequestInfo* temp = value_.info_;
    value_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_info(::types::RequestInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    value_.info_ = info;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.info)
}

// .types.RequestSetOption set_option = 5;
inline bool Request::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Request::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Request::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline  const ::types::RequestSetOption& Request::set_option() const {
  // @@protoc_insertion_point(field_get:types.Request.set_option)
  return has_set_option()
      ? *value_.set_option_
      : ::types::RequestSetOption::default_instance();
}
inline ::types::RequestSetOption* Request::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = new ::types::RequestSetOption;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.set_option)
  return value_.set_option_;
}
inline ::types::RequestSetOption* Request::release_set_option() {
  // @@protoc_insertion_point(field_release:types.Request.set_option)
  if (has_set_option()) {
    clear_has_value();
    ::types::RequestSetOption* temp = value_.set_option_;
    value_.set_option_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_set_option(::types::RequestSetOption* set_option) {
  clear_value();
  if (set_option) {
    set_has_set_option();
    value_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.set_option)
}

// .types.RequestInitChain init_chain = 6;
inline bool Request::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Request::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Request::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline  const ::types::RequestInitChain& Request::init_chain() const {
  // @@protoc_insertion_point(field_get:types.Request.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : ::types::RequestInitChain::default_instance();
}
inline ::types::RequestInitChain* Request::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = new ::types::RequestInitChain;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.init_chain)
  return value_.init_chain_;
}
inline ::types::RequestInitChain* Request::release_init_chain() {
  // @@protoc_insertion_point(field_release:types.Request.init_chain)
  if (has_init_chain()) {
    clear_has_value();
    ::types::RequestInitChain* temp = value_.init_chain_;
    value_.init_chain_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_init_chain(::types::RequestInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.init_chain)
}

// .types.RequestQuery query = 7;
inline bool Request::has_query() const {
  return value_case() == kQuery;
}
inline void Request::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Request::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline  const ::types::RequestQuery& Request::query() const {
  // @@protoc_insertion_point(field_get:types.Request.query)
  return has_query()
      ? *value_.query_
      : ::types::RequestQuery::default_instance();
}
inline ::types::RequestQuery* Request::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = new ::types::RequestQuery;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.query)
  return value_.query_;
}
inline ::types::RequestQuery* Request::release_query() {
  // @@protoc_insertion_point(field_release:types.Request.query)
  if (has_query()) {
    clear_has_value();
    ::types::RequestQuery* temp = value_.query_;
    value_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_query(::types::RequestQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    value_.query_ = query;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.query)
}

// .types.RequestBeginBlock begin_block = 8;
inline bool Request::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Request::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Request::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline  const ::types::RequestBeginBlock& Request::begin_block() const {
  // @@protoc_insertion_point(field_get:types.Request.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : ::types::RequestBeginBlock::default_instance();
}
inline ::types::RequestBeginBlock* Request::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = new ::types::RequestBeginBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.begin_block)
  return value_.begin_block_;
}
inline ::types::RequestBeginBlock* Request::release_begin_block() {
  // @@protoc_insertion_point(field_release:types.Request.begin_block)
  if (has_begin_block()) {
    clear_has_value();
    ::types::RequestBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_begin_block(::types::RequestBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.begin_block)
}

// .types.RequestCheckTx check_tx = 9;
inline bool Request::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Request::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Request::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline  const ::types::RequestCheckTx& Request::check_tx() const {
  // @@protoc_insertion_point(field_get:types.Request.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : ::types::RequestCheckTx::default_instance();
}
inline ::types::RequestCheckTx* Request::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = new ::types::RequestCheckTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.check_tx)
  return value_.check_tx_;
}
inline ::types::RequestCheckTx* Request::release_check_tx() {
  // @@protoc_insertion_point(field_release:types.Request.check_tx)
  if (has_check_tx()) {
    clear_has_value();
    ::types::RequestCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_check_tx(::types::RequestCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.check_tx)
}

// .types.RequestDeliverTx deliver_tx = 19;
inline bool Request::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Request::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Request::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline  const ::types::RequestDeliverTx& Request::deliver_tx() const {
  // @@protoc_insertion_point(field_get:types.Request.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : ::types::RequestDeliverTx::default_instance();
}
inline ::types::RequestDeliverTx* Request::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = new ::types::RequestDeliverTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.deliver_tx)
  return value_.deliver_tx_;
}
inline ::types::RequestDeliverTx* Request::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:types.Request.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
    ::types::RequestDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_deliver_tx(::types::RequestDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.deliver_tx)
}

// .types.RequestEndBlock end_block = 11;
inline bool Request::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Request::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Request::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline  const ::types::RequestEndBlock& Request::end_block() const {
  // @@protoc_insertion_point(field_get:types.Request.end_block)
  return has_end_block()
      ? *value_.end_block_
      : ::types::RequestEndBlock::default_instance();
}
inline ::types::RequestEndBlock* Request::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = new ::types::RequestEndBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.end_block)
  return value_.end_block_;
}
inline ::types::RequestEndBlock* Request::release_end_block() {
  // @@protoc_insertion_point(field_release:types.Request.end_block)
  if (has_end_block()) {
    clear_has_value();
    ::types::RequestEndBlock* temp = value_.end_block_;
    value_.end_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_end_block(::types::RequestEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.end_block)
}

// .types.RequestCommit commit = 12;
inline bool Request::has_commit() const {
  return value_case() == kCommit;
}
inline void Request::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Request::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline  const ::types::RequestCommit& Request::commit() const {
  // @@protoc_insertion_point(field_get:types.Request.commit)
  return has_commit()
      ? *value_.commit_
      : ::types::RequestCommit::default_instance();
}
inline ::types::RequestCommit* Request::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = new ::types::RequestCommit;
  }
  // @@protoc_insertion_point(field_mutable:types.Request.commit)
  return value_.commit_;
}
inline ::types::RequestCommit* Request::release_commit() {
  // @@protoc_insertion_point(field_release:types.Request.commit)
  if (has_commit()) {
    clear_has_value();
    ::types::RequestCommit* temp = value_.commit_;
    value_.commit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Request::set_allocated_commit(::types::RequestCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Request.commit)
}

inline bool Request::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Request::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Request::ValueCase Request::value_case() const {
  return Request::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RequestEcho

// string message = 1;
inline void RequestEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestEcho::message() const {
  // @@protoc_insertion_point(field_get:types.RequestEcho.message)
  return message_.GetNoArena();
}
inline void RequestEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestEcho.message)
}
#if LANG_CXX11
inline void RequestEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestEcho.message)
}
#endif
inline void RequestEcho::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestEcho.message)
}
inline void RequestEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestEcho.message)
}
inline ::std::string* RequestEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestEcho::release_message() {
  // @@protoc_insertion_point(field_release:types.RequestEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestEcho::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:types.RequestEcho.message)
}

// -------------------------------------------------------------------

// RequestFlush

// -------------------------------------------------------------------

// RequestInfo

// string version = 1;
inline void RequestInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInfo::version() const {
  // @@protoc_insertion_point(field_get:types.RequestInfo.version)
  return version_.GetNoArena();
}
inline void RequestInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestInfo.version)
}
#if LANG_CXX11
inline void RequestInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestInfo.version)
}
#endif
inline void RequestInfo::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestInfo.version)
}
inline void RequestInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestInfo.version)
}
inline ::std::string* RequestInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInfo::release_version() {
  // @@protoc_insertion_point(field_release:types.RequestInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:types.RequestInfo.version)
}

// uint64 block_version = 2;
inline void RequestInfo::clear_block_version() {
  block_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestInfo::block_version() const {
  // @@protoc_insertion_point(field_get:types.RequestInfo.block_version)
  return block_version_;
}
inline void RequestInfo::set_block_version(::google::protobuf::uint64 value) {
  
  block_version_ = value;
  // @@protoc_insertion_point(field_set:types.RequestInfo.block_version)
}

// uint64 p2p_version = 3;
inline void RequestInfo::clear_p2p_version() {
  p2p_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RequestInfo::p2p_version() const {
  // @@protoc_insertion_point(field_get:types.RequestInfo.p2p_version)
  return p2p_version_;
}
inline void RequestInfo::set_p2p_version(::google::protobuf::uint64 value) {
  
  p2p_version_ = value;
  // @@protoc_insertion_point(field_set:types.RequestInfo.p2p_version)
}

// -------------------------------------------------------------------

// RequestSetOption

// string key = 1;
inline void RequestSetOption::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::key() const {
  // @@protoc_insertion_point(field_get:types.RequestSetOption.key)
  return key_.GetNoArena();
}
inline void RequestSetOption::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestSetOption.key)
}
#if LANG_CXX11
inline void RequestSetOption::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestSetOption.key)
}
#endif
inline void RequestSetOption::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestSetOption.key)
}
inline void RequestSetOption::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestSetOption.key)
}
inline ::std::string* RequestSetOption::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestSetOption.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_key() {
  // @@protoc_insertion_point(field_release:types.RequestSetOption.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.RequestSetOption.key)
}

// string value = 2;
inline void RequestSetOption::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestSetOption::value() const {
  // @@protoc_insertion_point(field_get:types.RequestSetOption.value)
  return value_.GetNoArena();
}
inline void RequestSetOption::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestSetOption.value)
}
#if LANG_CXX11
inline void RequestSetOption::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestSetOption.value)
}
#endif
inline void RequestSetOption::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestSetOption.value)
}
inline void RequestSetOption::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestSetOption.value)
}
inline ::std::string* RequestSetOption::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestSetOption.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestSetOption::release_value() {
  // @@protoc_insertion_point(field_release:types.RequestSetOption.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestSetOption::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.RequestSetOption.value)
}

// -------------------------------------------------------------------

// RequestInitChain

// .google.protobuf.Timestamp time = 1 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool RequestInitChain::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline void RequestInitChain::clear_time() {
  if (GetArenaNoVirtual() == NULL && time_ != NULL) delete time_;
  time_ = NULL;
}
inline const ::google::protobuf::Timestamp& RequestInitChain::time() const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.time)
  return time_ != NULL ? *time_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* RequestInitChain::mutable_time() {
  
  if (time_ == NULL) {
    time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.time)
  return time_;
}
inline ::google::protobuf::Timestamp* RequestInitChain::release_time() {
  // @@protoc_insertion_point(field_release:types.RequestInitChain.time)
  
  ::google::protobuf::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline void RequestInitChain::set_allocated_time(::google::protobuf::Timestamp* time) {
  delete time_;
  if (time != NULL && time->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_time = new ::google::protobuf::Timestamp;
    new_time->CopyFrom(*time);
    time = new_time;
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.RequestInitChain.time)
}

// string chain_id = 2;
inline void RequestInitChain::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInitChain::chain_id() const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.chain_id)
  return chain_id_.GetNoArena();
}
inline void RequestInitChain::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestInitChain.chain_id)
}
#if LANG_CXX11
inline void RequestInitChain::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestInitChain.chain_id)
}
#endif
inline void RequestInitChain::set_chain_id(const char* value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestInitChain.chain_id)
}
inline void RequestInitChain::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestInitChain.chain_id)
}
inline ::std::string* RequestInitChain::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInitChain::release_chain_id() {
  // @@protoc_insertion_point(field_release:types.RequestInitChain.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInitChain::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != NULL) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:types.RequestInitChain.chain_id)
}

// .types.ConsensusParams consensus_params = 3;
inline bool RequestInitChain::has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != NULL;
}
inline void RequestInitChain::clear_consensus_params() {
  if (GetArenaNoVirtual() == NULL && consensus_params_ != NULL) delete consensus_params_;
  consensus_params_ = NULL;
}
inline const ::types::ConsensusParams& RequestInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.consensus_params)
  return consensus_params_ != NULL ? *consensus_params_
                         : *::types::ConsensusParams::internal_default_instance();
}
inline ::types::ConsensusParams* RequestInitChain::mutable_consensus_params() {
  
  if (consensus_params_ == NULL) {
    consensus_params_ = new ::types::ConsensusParams;
  }
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.consensus_params)
  return consensus_params_;
}
inline ::types::ConsensusParams* RequestInitChain::release_consensus_params() {
  // @@protoc_insertion_point(field_release:types.RequestInitChain.consensus_params)
  
  ::types::ConsensusParams* temp = consensus_params_;
  consensus_params_ = NULL;
  return temp;
}
inline void RequestInitChain::set_allocated_consensus_params(::types::ConsensusParams* consensus_params) {
  delete consensus_params_;
  consensus_params_ = consensus_params;
  if (consensus_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.RequestInitChain.consensus_params)
}

// repeated .types.ValidatorUpdate validators = 4 [(.gogoproto.nullable) = false];
inline int RequestInitChain::validators_size() const {
  return validators_.size();
}
inline void RequestInitChain::clear_validators() {
  validators_.Clear();
}
inline const ::types::ValidatorUpdate& RequestInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.validators)
  return validators_.Get(index);
}
inline ::types::ValidatorUpdate* RequestInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.validators)
  return validators_.Mutable(index);
}
inline ::types::ValidatorUpdate* RequestInitChain::add_validators() {
  // @@protoc_insertion_point(field_add:types.RequestInitChain.validators)
  return validators_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
RequestInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.RequestInitChain.validators)
  return &validators_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
RequestInitChain::validators() const {
  // @@protoc_insertion_point(field_list:types.RequestInitChain.validators)
  return validators_;
}

// bytes app_state_bytes = 5;
inline void RequestInitChain::clear_app_state_bytes() {
  app_state_bytes_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestInitChain::app_state_bytes() const {
  // @@protoc_insertion_point(field_get:types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.GetNoArena();
}
inline void RequestInitChain::set_app_state_bytes(const ::std::string& value) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestInitChain.app_state_bytes)
}
#if LANG_CXX11
inline void RequestInitChain::set_app_state_bytes(::std::string&& value) {
  
  app_state_bytes_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestInitChain.app_state_bytes)
}
#endif
inline void RequestInitChain::set_app_state_bytes(const char* value) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestInitChain.app_state_bytes)
}
inline void RequestInitChain::set_app_state_bytes(const void* value, size_t size) {
  
  app_state_bytes_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestInitChain.app_state_bytes)
}
inline ::std::string* RequestInitChain::mutable_app_state_bytes() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestInitChain.app_state_bytes)
  return app_state_bytes_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestInitChain::release_app_state_bytes() {
  // @@protoc_insertion_point(field_release:types.RequestInitChain.app_state_bytes)
  
  return app_state_bytes_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestInitChain::set_allocated_app_state_bytes(::std::string* app_state_bytes) {
  if (app_state_bytes != NULL) {
    
  } else {
    
  }
  app_state_bytes_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_state_bytes);
  // @@protoc_insertion_point(field_set_allocated:types.RequestInitChain.app_state_bytes)
}

// -------------------------------------------------------------------

// RequestQuery

// bytes data = 1;
inline void RequestQuery::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::data() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.data)
  return data_.GetNoArena();
}
inline void RequestQuery::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestQuery.data)
}
#if LANG_CXX11
inline void RequestQuery::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestQuery.data)
}
#endif
inline void RequestQuery::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestQuery.data)
}
inline void RequestQuery::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestQuery.data)
}
inline ::std::string* RequestQuery::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestQuery.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_data() {
  // @@protoc_insertion_point(field_release:types.RequestQuery.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.RequestQuery.data)
}

// string path = 2;
inline void RequestQuery::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestQuery::path() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.path)
  return path_.GetNoArena();
}
inline void RequestQuery::set_path(const ::std::string& value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestQuery.path)
}
#if LANG_CXX11
inline void RequestQuery::set_path(::std::string&& value) {
  
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestQuery.path)
}
#endif
inline void RequestQuery::set_path(const char* value) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestQuery.path)
}
inline void RequestQuery::set_path(const char* value, size_t size) {
  
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestQuery.path)
}
inline ::std::string* RequestQuery::mutable_path() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestQuery.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestQuery::release_path() {
  // @@protoc_insertion_point(field_release:types.RequestQuery.path)
  
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestQuery::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    
  } else {
    
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:types.RequestQuery.path)
}

// int64 height = 3;
inline void RequestQuery::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestQuery::height() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.height)
  return height_;
}
inline void RequestQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.RequestQuery.height)
}

// bool prove = 4;
inline void RequestQuery::clear_prove() {
  prove_ = false;
}
inline bool RequestQuery::prove() const {
  // @@protoc_insertion_point(field_get:types.RequestQuery.prove)
  return prove_;
}
inline void RequestQuery::set_prove(bool value) {
  
  prove_ = value;
  // @@protoc_insertion_point(field_set:types.RequestQuery.prove)
}

// -------------------------------------------------------------------

// RequestBeginBlock

// bytes hash = 1;
inline void RequestBeginBlock::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestBeginBlock::hash() const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.hash)
  return hash_.GetNoArena();
}
inline void RequestBeginBlock::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestBeginBlock.hash)
}
#if LANG_CXX11
inline void RequestBeginBlock::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestBeginBlock.hash)
}
#endif
inline void RequestBeginBlock::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestBeginBlock.hash)
}
inline void RequestBeginBlock::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestBeginBlock.hash)
}
inline ::std::string* RequestBeginBlock::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestBeginBlock::release_hash() {
  // @@protoc_insertion_point(field_release:types.RequestBeginBlock.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestBeginBlock::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.RequestBeginBlock.hash)
}

// .types.Header header = 2 [(.gogoproto.nullable) = false];
inline bool RequestBeginBlock::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void RequestBeginBlock::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::types::Header& RequestBeginBlock::header() const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.header)
  return header_ != NULL ? *header_
                         : *::types::Header::internal_default_instance();
}
inline ::types::Header* RequestBeginBlock::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::types::Header;
  }
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.header)
  return header_;
}
inline ::types::Header* RequestBeginBlock::release_header() {
  // @@protoc_insertion_point(field_release:types.RequestBeginBlock.header)
  
  ::types::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void RequestBeginBlock::set_allocated_header(::types::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.RequestBeginBlock.header)
}

// .types.LastCommitInfo last_commit_info = 3 [(.gogoproto.nullable) = false];
inline bool RequestBeginBlock::has_last_commit_info() const {
  return this != internal_default_instance() && last_commit_info_ != NULL;
}
inline void RequestBeginBlock::clear_last_commit_info() {
  if (GetArenaNoVirtual() == NULL && last_commit_info_ != NULL) delete last_commit_info_;
  last_commit_info_ = NULL;
}
inline const ::types::LastCommitInfo& RequestBeginBlock::last_commit_info() const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.last_commit_info)
  return last_commit_info_ != NULL ? *last_commit_info_
                         : *::types::LastCommitInfo::internal_default_instance();
}
inline ::types::LastCommitInfo* RequestBeginBlock::mutable_last_commit_info() {
  
  if (last_commit_info_ == NULL) {
    last_commit_info_ = new ::types::LastCommitInfo;
  }
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.last_commit_info)
  return last_commit_info_;
}
inline ::types::LastCommitInfo* RequestBeginBlock::release_last_commit_info() {
  // @@protoc_insertion_point(field_release:types.RequestBeginBlock.last_commit_info)
  
  ::types::LastCommitInfo* temp = last_commit_info_;
  last_commit_info_ = NULL;
  return temp;
}
inline void RequestBeginBlock::set_allocated_last_commit_info(::types::LastCommitInfo* last_commit_info) {
  delete last_commit_info_;
  last_commit_info_ = last_commit_info;
  if (last_commit_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.RequestBeginBlock.last_commit_info)
}

// repeated .types.Evidence byzantine_validators = 4 [(.gogoproto.nullable) = false];
inline int RequestBeginBlock::byzantine_validators_size() const {
  return byzantine_validators_.size();
}
inline void RequestBeginBlock::clear_byzantine_validators() {
  byzantine_validators_.Clear();
}
inline const ::types::Evidence& RequestBeginBlock::byzantine_validators(int index) const {
  // @@protoc_insertion_point(field_get:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Get(index);
}
inline ::types::Evidence* RequestBeginBlock::mutable_byzantine_validators(int index) {
  // @@protoc_insertion_point(field_mutable:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Mutable(index);
}
inline ::types::Evidence* RequestBeginBlock::add_byzantine_validators() {
  // @@protoc_insertion_point(field_add:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::Evidence >*
RequestBeginBlock::mutable_byzantine_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.RequestBeginBlock.byzantine_validators)
  return &byzantine_validators_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Evidence >&
RequestBeginBlock::byzantine_validators() const {
  // @@protoc_insertion_point(field_list:types.RequestBeginBlock.byzantine_validators)
  return byzantine_validators_;
}

// -------------------------------------------------------------------

// RequestCheckTx

// bytes tx = 1;
inline void RequestCheckTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestCheckTx::tx() const {
  // @@protoc_insertion_point(field_get:types.RequestCheckTx.tx)
  return tx_.GetNoArena();
}
inline void RequestCheckTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestCheckTx.tx)
}
#if LANG_CXX11
inline void RequestCheckTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestCheckTx.tx)
}
#endif
inline void RequestCheckTx::set_tx(const char* value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestCheckTx.tx)
}
inline void RequestCheckTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestCheckTx.tx)
}
inline ::std::string* RequestCheckTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestCheckTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestCheckTx::release_tx() {
  // @@protoc_insertion_point(field_release:types.RequestCheckTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestCheckTx::set_allocated_tx(::std::string* tx) {
  if (tx != NULL) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:types.RequestCheckTx.tx)
}

// -------------------------------------------------------------------

// RequestDeliverTx

// bytes tx = 1;
inline void RequestDeliverTx::clear_tx() {
  tx_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestDeliverTx::tx() const {
  // @@protoc_insertion_point(field_get:types.RequestDeliverTx.tx)
  return tx_.GetNoArena();
}
inline void RequestDeliverTx::set_tx(const ::std::string& value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.RequestDeliverTx.tx)
}
#if LANG_CXX11
inline void RequestDeliverTx::set_tx(::std::string&& value) {
  
  tx_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.RequestDeliverTx.tx)
}
#endif
inline void RequestDeliverTx::set_tx(const char* value) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.RequestDeliverTx.tx)
}
inline void RequestDeliverTx::set_tx(const void* value, size_t size) {
  
  tx_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.RequestDeliverTx.tx)
}
inline ::std::string* RequestDeliverTx::mutable_tx() {
  
  // @@protoc_insertion_point(field_mutable:types.RequestDeliverTx.tx)
  return tx_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestDeliverTx::release_tx() {
  // @@protoc_insertion_point(field_release:types.RequestDeliverTx.tx)
  
  return tx_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestDeliverTx::set_allocated_tx(::std::string* tx) {
  if (tx != NULL) {
    
  } else {
    
  }
  tx_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx);
  // @@protoc_insertion_point(field_set_allocated:types.RequestDeliverTx.tx)
}

// -------------------------------------------------------------------

// RequestEndBlock

// int64 height = 1;
inline void RequestEndBlock::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestEndBlock::height() const {
  // @@protoc_insertion_point(field_get:types.RequestEndBlock.height)
  return height_;
}
inline void RequestEndBlock::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.RequestEndBlock.height)
}

// -------------------------------------------------------------------

// RequestCommit

// -------------------------------------------------------------------

// Response

// .types.ResponseException exception = 1;
inline bool Response::has_exception() const {
  return value_case() == kException;
}
inline void Response::set_has_exception() {
  _oneof_case_[0] = kException;
}
inline void Response::clear_exception() {
  if (has_exception()) {
    delete value_.exception_;
    clear_has_value();
  }
}
inline  const ::types::ResponseException& Response::exception() const {
  // @@protoc_insertion_point(field_get:types.Response.exception)
  return has_exception()
      ? *value_.exception_
      : ::types::ResponseException::default_instance();
}
inline ::types::ResponseException* Response::mutable_exception() {
  if (!has_exception()) {
    clear_value();
    set_has_exception();
    value_.exception_ = new ::types::ResponseException;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.exception)
  return value_.exception_;
}
inline ::types::ResponseException* Response::release_exception() {
  // @@protoc_insertion_point(field_release:types.Response.exception)
  if (has_exception()) {
    clear_has_value();
    ::types::ResponseException* temp = value_.exception_;
    value_.exception_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_exception(::types::ResponseException* exception) {
  clear_value();
  if (exception) {
    set_has_exception();
    value_.exception_ = exception;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.exception)
}

// .types.ResponseEcho echo = 2;
inline bool Response::has_echo() const {
  return value_case() == kEcho;
}
inline void Response::set_has_echo() {
  _oneof_case_[0] = kEcho;
}
inline void Response::clear_echo() {
  if (has_echo()) {
    delete value_.echo_;
    clear_has_value();
  }
}
inline  const ::types::ResponseEcho& Response::echo() const {
  // @@protoc_insertion_point(field_get:types.Response.echo)
  return has_echo()
      ? *value_.echo_
      : ::types::ResponseEcho::default_instance();
}
inline ::types::ResponseEcho* Response::mutable_echo() {
  if (!has_echo()) {
    clear_value();
    set_has_echo();
    value_.echo_ = new ::types::ResponseEcho;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.echo)
  return value_.echo_;
}
inline ::types::ResponseEcho* Response::release_echo() {
  // @@protoc_insertion_point(field_release:types.Response.echo)
  if (has_echo()) {
    clear_has_value();
    ::types::ResponseEcho* temp = value_.echo_;
    value_.echo_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_echo(::types::ResponseEcho* echo) {
  clear_value();
  if (echo) {
    set_has_echo();
    value_.echo_ = echo;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.echo)
}

// .types.ResponseFlush flush = 3;
inline bool Response::has_flush() const {
  return value_case() == kFlush;
}
inline void Response::set_has_flush() {
  _oneof_case_[0] = kFlush;
}
inline void Response::clear_flush() {
  if (has_flush()) {
    delete value_.flush_;
    clear_has_value();
  }
}
inline  const ::types::ResponseFlush& Response::flush() const {
  // @@protoc_insertion_point(field_get:types.Response.flush)
  return has_flush()
      ? *value_.flush_
      : ::types::ResponseFlush::default_instance();
}
inline ::types::ResponseFlush* Response::mutable_flush() {
  if (!has_flush()) {
    clear_value();
    set_has_flush();
    value_.flush_ = new ::types::ResponseFlush;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.flush)
  return value_.flush_;
}
inline ::types::ResponseFlush* Response::release_flush() {
  // @@protoc_insertion_point(field_release:types.Response.flush)
  if (has_flush()) {
    clear_has_value();
    ::types::ResponseFlush* temp = value_.flush_;
    value_.flush_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_flush(::types::ResponseFlush* flush) {
  clear_value();
  if (flush) {
    set_has_flush();
    value_.flush_ = flush;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.flush)
}

// .types.ResponseInfo info = 4;
inline bool Response::has_info() const {
  return value_case() == kInfo;
}
inline void Response::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Response::clear_info() {
  if (has_info()) {
    delete value_.info_;
    clear_has_value();
  }
}
inline  const ::types::ResponseInfo& Response::info() const {
  // @@protoc_insertion_point(field_get:types.Response.info)
  return has_info()
      ? *value_.info_
      : ::types::ResponseInfo::default_instance();
}
inline ::types::ResponseInfo* Response::mutable_info() {
  if (!has_info()) {
    clear_value();
    set_has_info();
    value_.info_ = new ::types::ResponseInfo;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.info)
  return value_.info_;
}
inline ::types::ResponseInfo* Response::release_info() {
  // @@protoc_insertion_point(field_release:types.Response.info)
  if (has_info()) {
    clear_has_value();
    ::types::ResponseInfo* temp = value_.info_;
    value_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_info(::types::ResponseInfo* info) {
  clear_value();
  if (info) {
    set_has_info();
    value_.info_ = info;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.info)
}

// .types.ResponseSetOption set_option = 5;
inline bool Response::has_set_option() const {
  return value_case() == kSetOption;
}
inline void Response::set_has_set_option() {
  _oneof_case_[0] = kSetOption;
}
inline void Response::clear_set_option() {
  if (has_set_option()) {
    delete value_.set_option_;
    clear_has_value();
  }
}
inline  const ::types::ResponseSetOption& Response::set_option() const {
  // @@protoc_insertion_point(field_get:types.Response.set_option)
  return has_set_option()
      ? *value_.set_option_
      : ::types::ResponseSetOption::default_instance();
}
inline ::types::ResponseSetOption* Response::mutable_set_option() {
  if (!has_set_option()) {
    clear_value();
    set_has_set_option();
    value_.set_option_ = new ::types::ResponseSetOption;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.set_option)
  return value_.set_option_;
}
inline ::types::ResponseSetOption* Response::release_set_option() {
  // @@protoc_insertion_point(field_release:types.Response.set_option)
  if (has_set_option()) {
    clear_has_value();
    ::types::ResponseSetOption* temp = value_.set_option_;
    value_.set_option_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_set_option(::types::ResponseSetOption* set_option) {
  clear_value();
  if (set_option) {
    set_has_set_option();
    value_.set_option_ = set_option;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.set_option)
}

// .types.ResponseInitChain init_chain = 6;
inline bool Response::has_init_chain() const {
  return value_case() == kInitChain;
}
inline void Response::set_has_init_chain() {
  _oneof_case_[0] = kInitChain;
}
inline void Response::clear_init_chain() {
  if (has_init_chain()) {
    delete value_.init_chain_;
    clear_has_value();
  }
}
inline  const ::types::ResponseInitChain& Response::init_chain() const {
  // @@protoc_insertion_point(field_get:types.Response.init_chain)
  return has_init_chain()
      ? *value_.init_chain_
      : ::types::ResponseInitChain::default_instance();
}
inline ::types::ResponseInitChain* Response::mutable_init_chain() {
  if (!has_init_chain()) {
    clear_value();
    set_has_init_chain();
    value_.init_chain_ = new ::types::ResponseInitChain;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.init_chain)
  return value_.init_chain_;
}
inline ::types::ResponseInitChain* Response::release_init_chain() {
  // @@protoc_insertion_point(field_release:types.Response.init_chain)
  if (has_init_chain()) {
    clear_has_value();
    ::types::ResponseInitChain* temp = value_.init_chain_;
    value_.init_chain_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_init_chain(::types::ResponseInitChain* init_chain) {
  clear_value();
  if (init_chain) {
    set_has_init_chain();
    value_.init_chain_ = init_chain;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.init_chain)
}

// .types.ResponseQuery query = 7;
inline bool Response::has_query() const {
  return value_case() == kQuery;
}
inline void Response::set_has_query() {
  _oneof_case_[0] = kQuery;
}
inline void Response::clear_query() {
  if (has_query()) {
    delete value_.query_;
    clear_has_value();
  }
}
inline  const ::types::ResponseQuery& Response::query() const {
  // @@protoc_insertion_point(field_get:types.Response.query)
  return has_query()
      ? *value_.query_
      : ::types::ResponseQuery::default_instance();
}
inline ::types::ResponseQuery* Response::mutable_query() {
  if (!has_query()) {
    clear_value();
    set_has_query();
    value_.query_ = new ::types::ResponseQuery;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.query)
  return value_.query_;
}
inline ::types::ResponseQuery* Response::release_query() {
  // @@protoc_insertion_point(field_release:types.Response.query)
  if (has_query()) {
    clear_has_value();
    ::types::ResponseQuery* temp = value_.query_;
    value_.query_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_query(::types::ResponseQuery* query) {
  clear_value();
  if (query) {
    set_has_query();
    value_.query_ = query;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.query)
}

// .types.ResponseBeginBlock begin_block = 8;
inline bool Response::has_begin_block() const {
  return value_case() == kBeginBlock;
}
inline void Response::set_has_begin_block() {
  _oneof_case_[0] = kBeginBlock;
}
inline void Response::clear_begin_block() {
  if (has_begin_block()) {
    delete value_.begin_block_;
    clear_has_value();
  }
}
inline  const ::types::ResponseBeginBlock& Response::begin_block() const {
  // @@protoc_insertion_point(field_get:types.Response.begin_block)
  return has_begin_block()
      ? *value_.begin_block_
      : ::types::ResponseBeginBlock::default_instance();
}
inline ::types::ResponseBeginBlock* Response::mutable_begin_block() {
  if (!has_begin_block()) {
    clear_value();
    set_has_begin_block();
    value_.begin_block_ = new ::types::ResponseBeginBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.begin_block)
  return value_.begin_block_;
}
inline ::types::ResponseBeginBlock* Response::release_begin_block() {
  // @@protoc_insertion_point(field_release:types.Response.begin_block)
  if (has_begin_block()) {
    clear_has_value();
    ::types::ResponseBeginBlock* temp = value_.begin_block_;
    value_.begin_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_begin_block(::types::ResponseBeginBlock* begin_block) {
  clear_value();
  if (begin_block) {
    set_has_begin_block();
    value_.begin_block_ = begin_block;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.begin_block)
}

// .types.ResponseCheckTx check_tx = 9;
inline bool Response::has_check_tx() const {
  return value_case() == kCheckTx;
}
inline void Response::set_has_check_tx() {
  _oneof_case_[0] = kCheckTx;
}
inline void Response::clear_check_tx() {
  if (has_check_tx()) {
    delete value_.check_tx_;
    clear_has_value();
  }
}
inline  const ::types::ResponseCheckTx& Response::check_tx() const {
  // @@protoc_insertion_point(field_get:types.Response.check_tx)
  return has_check_tx()
      ? *value_.check_tx_
      : ::types::ResponseCheckTx::default_instance();
}
inline ::types::ResponseCheckTx* Response::mutable_check_tx() {
  if (!has_check_tx()) {
    clear_value();
    set_has_check_tx();
    value_.check_tx_ = new ::types::ResponseCheckTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.check_tx)
  return value_.check_tx_;
}
inline ::types::ResponseCheckTx* Response::release_check_tx() {
  // @@protoc_insertion_point(field_release:types.Response.check_tx)
  if (has_check_tx()) {
    clear_has_value();
    ::types::ResponseCheckTx* temp = value_.check_tx_;
    value_.check_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_check_tx(::types::ResponseCheckTx* check_tx) {
  clear_value();
  if (check_tx) {
    set_has_check_tx();
    value_.check_tx_ = check_tx;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.check_tx)
}

// .types.ResponseDeliverTx deliver_tx = 10;
inline bool Response::has_deliver_tx() const {
  return value_case() == kDeliverTx;
}
inline void Response::set_has_deliver_tx() {
  _oneof_case_[0] = kDeliverTx;
}
inline void Response::clear_deliver_tx() {
  if (has_deliver_tx()) {
    delete value_.deliver_tx_;
    clear_has_value();
  }
}
inline  const ::types::ResponseDeliverTx& Response::deliver_tx() const {
  // @@protoc_insertion_point(field_get:types.Response.deliver_tx)
  return has_deliver_tx()
      ? *value_.deliver_tx_
      : ::types::ResponseDeliverTx::default_instance();
}
inline ::types::ResponseDeliverTx* Response::mutable_deliver_tx() {
  if (!has_deliver_tx()) {
    clear_value();
    set_has_deliver_tx();
    value_.deliver_tx_ = new ::types::ResponseDeliverTx;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.deliver_tx)
  return value_.deliver_tx_;
}
inline ::types::ResponseDeliverTx* Response::release_deliver_tx() {
  // @@protoc_insertion_point(field_release:types.Response.deliver_tx)
  if (has_deliver_tx()) {
    clear_has_value();
    ::types::ResponseDeliverTx* temp = value_.deliver_tx_;
    value_.deliver_tx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_deliver_tx(::types::ResponseDeliverTx* deliver_tx) {
  clear_value();
  if (deliver_tx) {
    set_has_deliver_tx();
    value_.deliver_tx_ = deliver_tx;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.deliver_tx)
}

// .types.ResponseEndBlock end_block = 11;
inline bool Response::has_end_block() const {
  return value_case() == kEndBlock;
}
inline void Response::set_has_end_block() {
  _oneof_case_[0] = kEndBlock;
}
inline void Response::clear_end_block() {
  if (has_end_block()) {
    delete value_.end_block_;
    clear_has_value();
  }
}
inline  const ::types::ResponseEndBlock& Response::end_block() const {
  // @@protoc_insertion_point(field_get:types.Response.end_block)
  return has_end_block()
      ? *value_.end_block_
      : ::types::ResponseEndBlock::default_instance();
}
inline ::types::ResponseEndBlock* Response::mutable_end_block() {
  if (!has_end_block()) {
    clear_value();
    set_has_end_block();
    value_.end_block_ = new ::types::ResponseEndBlock;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.end_block)
  return value_.end_block_;
}
inline ::types::ResponseEndBlock* Response::release_end_block() {
  // @@protoc_insertion_point(field_release:types.Response.end_block)
  if (has_end_block()) {
    clear_has_value();
    ::types::ResponseEndBlock* temp = value_.end_block_;
    value_.end_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_end_block(::types::ResponseEndBlock* end_block) {
  clear_value();
  if (end_block) {
    set_has_end_block();
    value_.end_block_ = end_block;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.end_block)
}

// .types.ResponseCommit commit = 12;
inline bool Response::has_commit() const {
  return value_case() == kCommit;
}
inline void Response::set_has_commit() {
  _oneof_case_[0] = kCommit;
}
inline void Response::clear_commit() {
  if (has_commit()) {
    delete value_.commit_;
    clear_has_value();
  }
}
inline  const ::types::ResponseCommit& Response::commit() const {
  // @@protoc_insertion_point(field_get:types.Response.commit)
  return has_commit()
      ? *value_.commit_
      : ::types::ResponseCommit::default_instance();
}
inline ::types::ResponseCommit* Response::mutable_commit() {
  if (!has_commit()) {
    clear_value();
    set_has_commit();
    value_.commit_ = new ::types::ResponseCommit;
  }
  // @@protoc_insertion_point(field_mutable:types.Response.commit)
  return value_.commit_;
}
inline ::types::ResponseCommit* Response::release_commit() {
  // @@protoc_insertion_point(field_release:types.Response.commit)
  if (has_commit()) {
    clear_has_value();
    ::types::ResponseCommit* temp = value_.commit_;
    value_.commit_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Response::set_allocated_commit(::types::ResponseCommit* commit) {
  clear_value();
  if (commit) {
    set_has_commit();
    value_.commit_ = commit;
  }
  // @@protoc_insertion_point(field_set_allocated:types.Response.commit)
}

inline bool Response::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Response::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Response::ValueCase Response::value_case() const {
  return Response::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ResponseException

// string error = 1;
inline void ResponseException::clear_error() {
  error_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseException::error() const {
  // @@protoc_insertion_point(field_get:types.ResponseException.error)
  return error_.GetNoArena();
}
inline void ResponseException::set_error(const ::std::string& value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseException.error)
}
#if LANG_CXX11
inline void ResponseException::set_error(::std::string&& value) {
  
  error_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseException.error)
}
#endif
inline void ResponseException::set_error(const char* value) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseException.error)
}
inline void ResponseException::set_error(const char* value, size_t size) {
  
  error_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseException.error)
}
inline ::std::string* ResponseException::mutable_error() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseException.error)
  return error_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseException::release_error() {
  // @@protoc_insertion_point(field_release:types.ResponseException.error)
  
  return error_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseException::set_allocated_error(::std::string* error) {
  if (error != NULL) {
    
  } else {
    
  }
  error_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseException.error)
}

// -------------------------------------------------------------------

// ResponseEcho

// string message = 1;
inline void ResponseEcho::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseEcho::message() const {
  // @@protoc_insertion_point(field_get:types.ResponseEcho.message)
  return message_.GetNoArena();
}
inline void ResponseEcho::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseEcho.message)
}
#if LANG_CXX11
inline void ResponseEcho::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseEcho.message)
}
#endif
inline void ResponseEcho::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseEcho.message)
}
inline void ResponseEcho::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseEcho.message)
}
inline ::std::string* ResponseEcho::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseEcho.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseEcho::release_message() {
  // @@protoc_insertion_point(field_release:types.ResponseEcho.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseEcho::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseEcho.message)
}

// -------------------------------------------------------------------

// ResponseFlush

// -------------------------------------------------------------------

// ResponseInfo

// string data = 1;
inline void ResponseInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.data)
  return data_.GetNoArena();
}
inline void ResponseInfo::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.data)
}
#if LANG_CXX11
inline void ResponseInfo::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.data)
}
#endif
inline void ResponseInfo::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.data)
}
inline void ResponseInfo::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.data)
}
inline ::std::string* ResponseInfo::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.data)
}

// string version = 2;
inline void ResponseInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::version() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.version)
  return version_.GetNoArena();
}
inline void ResponseInfo::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.version)
}
#if LANG_CXX11
inline void ResponseInfo::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.version)
}
#endif
inline void ResponseInfo::set_version(const char* value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.version)
}
inline void ResponseInfo::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.version)
}
inline ::std::string* ResponseInfo::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_version() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.version)
}

// uint64 app_version = 3;
inline void ResponseInfo::clear_app_version() {
  app_version_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ResponseInfo::app_version() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.app_version)
  return app_version_;
}
inline void ResponseInfo::set_app_version(::google::protobuf::uint64 value) {
  
  app_version_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseInfo.app_version)
}

// int64 last_block_height = 4;
inline void ResponseInfo::clear_last_block_height() {
  last_block_height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseInfo::last_block_height() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.last_block_height)
  return last_block_height_;
}
inline void ResponseInfo::set_last_block_height(::google::protobuf::int64 value) {
  
  last_block_height_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseInfo.last_block_height)
}

// bytes last_block_app_hash = 5;
inline void ResponseInfo::clear_last_block_app_hash() {
  last_block_app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseInfo::last_block_app_hash() const {
  // @@protoc_insertion_point(field_get:types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.GetNoArena();
}
inline void ResponseInfo::set_last_block_app_hash(const ::std::string& value) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseInfo.last_block_app_hash)
}
#if LANG_CXX11
inline void ResponseInfo::set_last_block_app_hash(::std::string&& value) {
  
  last_block_app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseInfo.last_block_app_hash)
}
#endif
inline void ResponseInfo::set_last_block_app_hash(const char* value) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseInfo.last_block_app_hash)
}
inline void ResponseInfo::set_last_block_app_hash(const void* value, size_t size) {
  
  last_block_app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseInfo.last_block_app_hash)
}
inline ::std::string* ResponseInfo::mutable_last_block_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseInfo.last_block_app_hash)
  return last_block_app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseInfo::release_last_block_app_hash() {
  // @@protoc_insertion_point(field_release:types.ResponseInfo.last_block_app_hash)
  
  return last_block_app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseInfo::set_allocated_last_block_app_hash(::std::string* last_block_app_hash) {
  if (last_block_app_hash != NULL) {
    
  } else {
    
  }
  last_block_app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_block_app_hash);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInfo.last_block_app_hash)
}

// -------------------------------------------------------------------

// ResponseSetOption

// uint32 code = 1;
inline void ResponseSetOption::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseSetOption::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.code)
  return code_;
}
inline void ResponseSetOption::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.code)
}

// string log = 3;
inline void ResponseSetOption::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.log)
  return log_.GetNoArena();
}
inline void ResponseSetOption::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.log)
}
#if LANG_CXX11
inline void ResponseSetOption::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseSetOption.log)
}
#endif
inline void ResponseSetOption::set_log(const char* value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseSetOption.log)
}
inline void ResponseSetOption::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseSetOption.log)
}
inline ::std::string* ResponseSetOption::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseSetOption.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseSetOption.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseSetOption.log)
}

// string info = 4;
inline void ResponseSetOption::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseSetOption::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseSetOption.info)
  return info_.GetNoArena();
}
inline void ResponseSetOption::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseSetOption.info)
}
#if LANG_CXX11
inline void ResponseSetOption::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseSetOption.info)
}
#endif
inline void ResponseSetOption::set_info(const char* value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseSetOption.info)
}
inline void ResponseSetOption::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseSetOption.info)
}
inline ::std::string* ResponseSetOption::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseSetOption.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseSetOption::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseSetOption.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseSetOption::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseSetOption.info)
}

// -------------------------------------------------------------------

// ResponseInitChain

// .types.ConsensusParams consensus_params = 1;
inline bool ResponseInitChain::has_consensus_params() const {
  return this != internal_default_instance() && consensus_params_ != NULL;
}
inline void ResponseInitChain::clear_consensus_params() {
  if (GetArenaNoVirtual() == NULL && consensus_params_ != NULL) delete consensus_params_;
  consensus_params_ = NULL;
}
inline const ::types::ConsensusParams& ResponseInitChain::consensus_params() const {
  // @@protoc_insertion_point(field_get:types.ResponseInitChain.consensus_params)
  return consensus_params_ != NULL ? *consensus_params_
                         : *::types::ConsensusParams::internal_default_instance();
}
inline ::types::ConsensusParams* ResponseInitChain::mutable_consensus_params() {
  
  if (consensus_params_ == NULL) {
    consensus_params_ = new ::types::ConsensusParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseInitChain.consensus_params)
  return consensus_params_;
}
inline ::types::ConsensusParams* ResponseInitChain::release_consensus_params() {
  // @@protoc_insertion_point(field_release:types.ResponseInitChain.consensus_params)
  
  ::types::ConsensusParams* temp = consensus_params_;
  consensus_params_ = NULL;
  return temp;
}
inline void ResponseInitChain::set_allocated_consensus_params(::types::ConsensusParams* consensus_params) {
  delete consensus_params_;
  consensus_params_ = consensus_params;
  if (consensus_params) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ResponseInitChain.consensus_params)
}

// repeated .types.ValidatorUpdate validators = 2 [(.gogoproto.nullable) = false];
inline int ResponseInitChain::validators_size() const {
  return validators_.size();
}
inline void ResponseInitChain::clear_validators() {
  validators_.Clear();
}
inline const ::types::ValidatorUpdate& ResponseInitChain::validators(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseInitChain.validators)
  return validators_.Get(index);
}
inline ::types::ValidatorUpdate* ResponseInitChain::mutable_validators(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseInitChain.validators)
  return validators_.Mutable(index);
}
inline ::types::ValidatorUpdate* ResponseInitChain::add_validators() {
  // @@protoc_insertion_point(field_add:types.ResponseInitChain.validators)
  return validators_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
ResponseInitChain::mutable_validators() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseInitChain.validators)
  return &validators_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
ResponseInitChain::validators() const {
  // @@protoc_insertion_point(field_list:types.ResponseInitChain.validators)
  return validators_;
}

// -------------------------------------------------------------------

// ResponseQuery

// uint32 code = 1;
inline void ResponseQuery::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseQuery::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.code)
  return code_;
}
inline void ResponseQuery::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.code)
}

// string log = 3;
inline void ResponseQuery::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.log)
  return log_.GetNoArena();
}
inline void ResponseQuery::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.log)
}
#if LANG_CXX11
inline void ResponseQuery::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.log)
}
#endif
inline void ResponseQuery::set_log(const char* value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.log)
}
inline void ResponseQuery::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.log)
}
inline ::std::string* ResponseQuery::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.log)
}

// string info = 4;
inline void ResponseQuery::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.info)
  return info_.GetNoArena();
}
inline void ResponseQuery::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.info)
}
#if LANG_CXX11
inline void ResponseQuery::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.info)
}
#endif
inline void ResponseQuery::set_info(const char* value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.info)
}
inline void ResponseQuery::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.info)
}
inline ::std::string* ResponseQuery::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.info)
}

// int64 index = 5;
inline void ResponseQuery::clear_index() {
  index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::index() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.index)
  return index_;
}
inline void ResponseQuery::set_index(::google::protobuf::int64 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.index)
}

// bytes key = 6;
inline void ResponseQuery::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::key() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.key)
  return key_.GetNoArena();
}
inline void ResponseQuery::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.key)
}
#if LANG_CXX11
inline void ResponseQuery::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.key)
}
#endif
inline void ResponseQuery::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.key)
}
inline void ResponseQuery::set_key(const void* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.key)
}
inline ::std::string* ResponseQuery::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_key() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.key)
}

// bytes value = 7;
inline void ResponseQuery::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::value() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.value)
  return value_.GetNoArena();
}
inline void ResponseQuery::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.value)
}
#if LANG_CXX11
inline void ResponseQuery::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.value)
}
#endif
inline void ResponseQuery::set_value(const char* value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.value)
}
inline void ResponseQuery::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.value)
}
inline ::std::string* ResponseQuery::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_value() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.value)
}

// .merkle.Proof proof = 8;
inline bool ResponseQuery::has_proof() const {
  return this != internal_default_instance() && proof_ != NULL;
}
inline void ResponseQuery::clear_proof() {
  if (GetArenaNoVirtual() == NULL && proof_ != NULL) delete proof_;
  proof_ = NULL;
}
inline const ::merkle::Proof& ResponseQuery::proof() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.proof)
  return proof_ != NULL ? *proof_
                         : *::merkle::Proof::internal_default_instance();
}
inline ::merkle::Proof* ResponseQuery::mutable_proof() {
  
  if (proof_ == NULL) {
    proof_ = new ::merkle::Proof;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.proof)
  return proof_;
}
inline ::merkle::Proof* ResponseQuery::release_proof() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.proof)
  
  ::merkle::Proof* temp = proof_;
  proof_ = NULL;
  return temp;
}
inline void ResponseQuery::set_allocated_proof(::merkle::Proof* proof) {
  delete proof_;
  proof_ = proof;
  if (proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.proof)
}

// int64 height = 9;
inline void ResponseQuery::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseQuery::height() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.height)
  return height_;
}
inline void ResponseQuery::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseQuery.height)
}

// string codespace = 10;
inline void ResponseQuery::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseQuery::codespace() const {
  // @@protoc_insertion_point(field_get:types.ResponseQuery.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseQuery::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseQuery.codespace)
}
#if LANG_CXX11
inline void ResponseQuery::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseQuery.codespace)
}
#endif
inline void ResponseQuery::set_codespace(const char* value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseQuery.codespace)
}
inline void ResponseQuery::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseQuery.codespace)
}
inline ::std::string* ResponseQuery::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseQuery.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseQuery::release_codespace() {
  // @@protoc_insertion_point(field_release:types.ResponseQuery.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseQuery::set_allocated_codespace(::std::string* codespace) {
  if (codespace != NULL) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseQuery.codespace)
}

// -------------------------------------------------------------------

// ResponseBeginBlock

// repeated .common.KVPair tags = 1 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
inline int ResponseBeginBlock::tags_size() const {
  return tags_.size();
}
inline void ResponseBeginBlock::clear_tags() {
  tags_.Clear();
}
inline const ::common::KVPair& ResponseBeginBlock::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseBeginBlock.tags)
  return tags_.Get(index);
}
inline ::common::KVPair* ResponseBeginBlock::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseBeginBlock.tags)
  return tags_.Mutable(index);
}
inline ::common::KVPair* ResponseBeginBlock::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseBeginBlock.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
ResponseBeginBlock::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseBeginBlock.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
ResponseBeginBlock::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseBeginBlock.tags)
  return tags_;
}

// -------------------------------------------------------------------

// ResponseCheckTx

// uint32 code = 1;
inline void ResponseCheckTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseCheckTx::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.code)
  return code_;
}
inline void ResponseCheckTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.code)
}

// bytes data = 2;
inline void ResponseCheckTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.data)
  return data_.GetNoArena();
}
inline void ResponseCheckTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.data)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.data)
}
#endif
inline void ResponseCheckTx::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.data)
}
inline void ResponseCheckTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.data)
}
inline ::std::string* ResponseCheckTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.data)
}

// string log = 3;
inline void ResponseCheckTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.log)
  return log_.GetNoArena();
}
inline void ResponseCheckTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.log)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.log)
}
#endif
inline void ResponseCheckTx::set_log(const char* value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.log)
}
inline void ResponseCheckTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.log)
}
inline ::std::string* ResponseCheckTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.log)
}

// string info = 4;
inline void ResponseCheckTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.info)
  return info_.GetNoArena();
}
inline void ResponseCheckTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.info)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.info)
}
#endif
inline void ResponseCheckTx::set_info(const char* value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.info)
}
inline void ResponseCheckTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.info)
}
inline ::std::string* ResponseCheckTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseCheckTx::clear_gas_wanted() {
  gas_wanted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseCheckTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseCheckTx::clear_gas_used() {
  gas_used_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseCheckTx::gas_used() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.gas_used)
  return gas_used_;
}
inline void ResponseCheckTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.gas_used)
}

// repeated .common.KVPair tags = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
inline int ResponseCheckTx::tags_size() const {
  return tags_.size();
}
inline void ResponseCheckTx::clear_tags() {
  tags_.Clear();
}
inline const ::common::KVPair& ResponseCheckTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.tags)
  return tags_.Get(index);
}
inline ::common::KVPair* ResponseCheckTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.tags)
  return tags_.Mutable(index);
}
inline ::common::KVPair* ResponseCheckTx::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseCheckTx.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
ResponseCheckTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseCheckTx.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
ResponseCheckTx::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseCheckTx.tags)
  return tags_;
}

// string codespace = 8;
inline void ResponseCheckTx::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCheckTx::codespace() const {
  // @@protoc_insertion_point(field_get:types.ResponseCheckTx.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseCheckTx::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCheckTx.codespace)
}
#if LANG_CXX11
inline void ResponseCheckTx::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCheckTx.codespace)
}
#endif
inline void ResponseCheckTx::set_codespace(const char* value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCheckTx.codespace)
}
inline void ResponseCheckTx::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCheckTx.codespace)
}
inline ::std::string* ResponseCheckTx::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCheckTx.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCheckTx::release_codespace() {
  // @@protoc_insertion_point(field_release:types.ResponseCheckTx.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCheckTx::set_allocated_codespace(::std::string* codespace) {
  if (codespace != NULL) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCheckTx.codespace)
}

// -------------------------------------------------------------------

// ResponseDeliverTx

// uint32 code = 1;
inline void ResponseDeliverTx::clear_code() {
  code_ = 0u;
}
inline ::google::protobuf::uint32 ResponseDeliverTx::code() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.code)
  return code_;
}
inline void ResponseDeliverTx::set_code(::google::protobuf::uint32 value) {
  
  code_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.code)
}

// bytes data = 2;
inline void ResponseDeliverTx::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.data)
  return data_.GetNoArena();
}
inline void ResponseDeliverTx::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.data)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.data)
}
#endif
inline void ResponseDeliverTx::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.data)
}
inline void ResponseDeliverTx::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.data)
}
inline ::std::string* ResponseDeliverTx::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.data)
}

// string log = 3;
inline void ResponseDeliverTx::clear_log() {
  log_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::log() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.log)
  return log_.GetNoArena();
}
inline void ResponseDeliverTx::set_log(const ::std::string& value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.log)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_log(::std::string&& value) {
  
  log_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.log)
}
#endif
inline void ResponseDeliverTx::set_log(const char* value) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.log)
}
inline void ResponseDeliverTx::set_log(const char* value, size_t size) {
  
  log_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.log)
}
inline ::std::string* ResponseDeliverTx::mutable_log() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.log)
  return log_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_log() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.log)
  
  return log_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_log(::std::string* log) {
  if (log != NULL) {
    
  } else {
    
  }
  log_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), log);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.log)
}

// string info = 4;
inline void ResponseDeliverTx::clear_info() {
  info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::info() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.info)
  return info_.GetNoArena();
}
inline void ResponseDeliverTx::set_info(const ::std::string& value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.info)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_info(::std::string&& value) {
  
  info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.info)
}
#endif
inline void ResponseDeliverTx::set_info(const char* value) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.info)
}
inline void ResponseDeliverTx::set_info(const char* value, size_t size) {
  
  info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.info)
}
inline ::std::string* ResponseDeliverTx::mutable_info() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.info)
  return info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_info() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.info)
  
  return info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_info(::std::string* info) {
  if (info != NULL) {
    
  } else {
    
  }
  info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), info);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.info)
}

// int64 gas_wanted = 5;
inline void ResponseDeliverTx::clear_gas_wanted() {
  gas_wanted_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_wanted() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.gas_wanted)
  return gas_wanted_;
}
inline void ResponseDeliverTx::set_gas_wanted(::google::protobuf::int64 value) {
  
  gas_wanted_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.gas_wanted)
}

// int64 gas_used = 6;
inline void ResponseDeliverTx::clear_gas_used() {
  gas_used_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseDeliverTx::gas_used() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.gas_used)
  return gas_used_;
}
inline void ResponseDeliverTx::set_gas_used(::google::protobuf::int64 value) {
  
  gas_used_ = value;
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.gas_used)
}

// repeated .common.KVPair tags = 7 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
inline int ResponseDeliverTx::tags_size() const {
  return tags_.size();
}
inline void ResponseDeliverTx::clear_tags() {
  tags_.Clear();
}
inline const ::common::KVPair& ResponseDeliverTx::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.tags)
  return tags_.Get(index);
}
inline ::common::KVPair* ResponseDeliverTx::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.tags)
  return tags_.Mutable(index);
}
inline ::common::KVPair* ResponseDeliverTx::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseDeliverTx.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
ResponseDeliverTx::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseDeliverTx.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
ResponseDeliverTx::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseDeliverTx.tags)
  return tags_;
}

// string codespace = 8;
inline void ResponseDeliverTx::clear_codespace() {
  codespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseDeliverTx::codespace() const {
  // @@protoc_insertion_point(field_get:types.ResponseDeliverTx.codespace)
  return codespace_.GetNoArena();
}
inline void ResponseDeliverTx::set_codespace(const ::std::string& value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseDeliverTx.codespace)
}
#if LANG_CXX11
inline void ResponseDeliverTx::set_codespace(::std::string&& value) {
  
  codespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseDeliverTx.codespace)
}
#endif
inline void ResponseDeliverTx::set_codespace(const char* value) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseDeliverTx.codespace)
}
inline void ResponseDeliverTx::set_codespace(const char* value, size_t size) {
  
  codespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseDeliverTx.codespace)
}
inline ::std::string* ResponseDeliverTx::mutable_codespace() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseDeliverTx.codespace)
  return codespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseDeliverTx::release_codespace() {
  // @@protoc_insertion_point(field_release:types.ResponseDeliverTx.codespace)
  
  return codespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseDeliverTx::set_allocated_codespace(::std::string* codespace) {
  if (codespace != NULL) {
    
  } else {
    
  }
  codespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codespace);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseDeliverTx.codespace)
}

// -------------------------------------------------------------------

// ResponseEndBlock

// repeated .types.ValidatorUpdate validator_updates = 1 [(.gogoproto.nullable) = false];
inline int ResponseEndBlock::validator_updates_size() const {
  return validator_updates_.size();
}
inline void ResponseEndBlock::clear_validator_updates() {
  validator_updates_.Clear();
}
inline const ::types::ValidatorUpdate& ResponseEndBlock::validator_updates(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Get(index);
}
inline ::types::ValidatorUpdate* ResponseEndBlock::mutable_validator_updates(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Mutable(index);
}
inline ::types::ValidatorUpdate* ResponseEndBlock::add_validator_updates() {
  // @@protoc_insertion_point(field_add:types.ResponseEndBlock.validator_updates)
  return validator_updates_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >*
ResponseEndBlock::mutable_validator_updates() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseEndBlock.validator_updates)
  return &validator_updates_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ValidatorUpdate >&
ResponseEndBlock::validator_updates() const {
  // @@protoc_insertion_point(field_list:types.ResponseEndBlock.validator_updates)
  return validator_updates_;
}

// .types.ConsensusParams consensus_param_updates = 2;
inline bool ResponseEndBlock::has_consensus_param_updates() const {
  return this != internal_default_instance() && consensus_param_updates_ != NULL;
}
inline void ResponseEndBlock::clear_consensus_param_updates() {
  if (GetArenaNoVirtual() == NULL && consensus_param_updates_ != NULL) delete consensus_param_updates_;
  consensus_param_updates_ = NULL;
}
inline const ::types::ConsensusParams& ResponseEndBlock::consensus_param_updates() const {
  // @@protoc_insertion_point(field_get:types.ResponseEndBlock.consensus_param_updates)
  return consensus_param_updates_ != NULL ? *consensus_param_updates_
                         : *::types::ConsensusParams::internal_default_instance();
}
inline ::types::ConsensusParams* ResponseEndBlock::mutable_consensus_param_updates() {
  
  if (consensus_param_updates_ == NULL) {
    consensus_param_updates_ = new ::types::ConsensusParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ResponseEndBlock.consensus_param_updates)
  return consensus_param_updates_;
}
inline ::types::ConsensusParams* ResponseEndBlock::release_consensus_param_updates() {
  // @@protoc_insertion_point(field_release:types.ResponseEndBlock.consensus_param_updates)
  
  ::types::ConsensusParams* temp = consensus_param_updates_;
  consensus_param_updates_ = NULL;
  return temp;
}
inline void ResponseEndBlock::set_allocated_consensus_param_updates(::types::ConsensusParams* consensus_param_updates) {
  delete consensus_param_updates_;
  consensus_param_updates_ = consensus_param_updates;
  if (consensus_param_updates) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ResponseEndBlock.consensus_param_updates)
}

// repeated .common.KVPair tags = 3 [(.gogoproto.nullable) = false, (.gogoproto.jsontag) = "tags,omitempty"];
inline int ResponseEndBlock::tags_size() const {
  return tags_.size();
}
inline void ResponseEndBlock::clear_tags() {
  tags_.Clear();
}
inline const ::common::KVPair& ResponseEndBlock::tags(int index) const {
  // @@protoc_insertion_point(field_get:types.ResponseEndBlock.tags)
  return tags_.Get(index);
}
inline ::common::KVPair* ResponseEndBlock::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:types.ResponseEndBlock.tags)
  return tags_.Mutable(index);
}
inline ::common::KVPair* ResponseEndBlock::add_tags() {
  // @@protoc_insertion_point(field_add:types.ResponseEndBlock.tags)
  return tags_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::common::KVPair >*
ResponseEndBlock::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:types.ResponseEndBlock.tags)
  return &tags_;
}
inline const ::google::protobuf::RepeatedPtrField< ::common::KVPair >&
ResponseEndBlock::tags() const {
  // @@protoc_insertion_point(field_list:types.ResponseEndBlock.tags)
  return tags_;
}

// -------------------------------------------------------------------

// ResponseCommit

// bytes data = 2;
inline void ResponseCommit::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseCommit::data() const {
  // @@protoc_insertion_point(field_get:types.ResponseCommit.data)
  return data_.GetNoArena();
}
inline void ResponseCommit::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ResponseCommit.data)
}
#if LANG_CXX11
inline void ResponseCommit::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ResponseCommit.data)
}
#endif
inline void ResponseCommit::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ResponseCommit.data)
}
inline void ResponseCommit::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ResponseCommit.data)
}
inline ::std::string* ResponseCommit::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.ResponseCommit.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseCommit::release_data() {
  // @@protoc_insertion_point(field_release:types.ResponseCommit.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseCommit::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.ResponseCommit.data)
}

// -------------------------------------------------------------------

// ConsensusParams

// .types.BlockSizeParams block_size = 1;
inline bool ConsensusParams::has_block_size() const {
  return this != internal_default_instance() && block_size_ != NULL;
}
inline void ConsensusParams::clear_block_size() {
  if (GetArenaNoVirtual() == NULL && block_size_ != NULL) delete block_size_;
  block_size_ = NULL;
}
inline const ::types::BlockSizeParams& ConsensusParams::block_size() const {
  // @@protoc_insertion_point(field_get:types.ConsensusParams.block_size)
  return block_size_ != NULL ? *block_size_
                         : *::types::BlockSizeParams::internal_default_instance();
}
inline ::types::BlockSizeParams* ConsensusParams::mutable_block_size() {
  
  if (block_size_ == NULL) {
    block_size_ = new ::types::BlockSizeParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.block_size)
  return block_size_;
}
inline ::types::BlockSizeParams* ConsensusParams::release_block_size() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.block_size)
  
  ::types::BlockSizeParams* temp = block_size_;
  block_size_ = NULL;
  return temp;
}
inline void ConsensusParams::set_allocated_block_size(::types::BlockSizeParams* block_size) {
  delete block_size_;
  block_size_ = block_size;
  if (block_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.block_size)
}

// .types.EvidenceParams evidence = 2;
inline bool ConsensusParams::has_evidence() const {
  return this != internal_default_instance() && evidence_ != NULL;
}
inline void ConsensusParams::clear_evidence() {
  if (GetArenaNoVirtual() == NULL && evidence_ != NULL) delete evidence_;
  evidence_ = NULL;
}
inline const ::types::EvidenceParams& ConsensusParams::evidence() const {
  // @@protoc_insertion_point(field_get:types.ConsensusParams.evidence)
  return evidence_ != NULL ? *evidence_
                         : *::types::EvidenceParams::internal_default_instance();
}
inline ::types::EvidenceParams* ConsensusParams::mutable_evidence() {
  
  if (evidence_ == NULL) {
    evidence_ = new ::types::EvidenceParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.evidence)
  return evidence_;
}
inline ::types::EvidenceParams* ConsensusParams::release_evidence() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.evidence)
  
  ::types::EvidenceParams* temp = evidence_;
  evidence_ = NULL;
  return temp;
}
inline void ConsensusParams::set_allocated_evidence(::types::EvidenceParams* evidence) {
  delete evidence_;
  evidence_ = evidence;
  if (evidence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.evidence)
}

// .types.ValidatorParams validator = 3;
inline bool ConsensusParams::has_validator() const {
  return this != internal_default_instance() && validator_ != NULL;
}
inline void ConsensusParams::clear_validator() {
  if (GetArenaNoVirtual() == NULL && validator_ != NULL) delete validator_;
  validator_ = NULL;
}
inline const ::types::ValidatorParams& ConsensusParams::validator() const {
  // @@protoc_insertion_point(field_get:types.ConsensusParams.validator)
  return validator_ != NULL ? *validator_
                         : *::types::ValidatorParams::internal_default_instance();
}
inline ::types::ValidatorParams* ConsensusParams::mutable_validator() {
  
  if (validator_ == NULL) {
    validator_ = new ::types::ValidatorParams;
  }
  // @@protoc_insertion_point(field_mutable:types.ConsensusParams.validator)
  return validator_;
}
inline ::types::ValidatorParams* ConsensusParams::release_validator() {
  // @@protoc_insertion_point(field_release:types.ConsensusParams.validator)
  
  ::types::ValidatorParams* temp = validator_;
  validator_ = NULL;
  return temp;
}
inline void ConsensusParams::set_allocated_validator(::types::ValidatorParams* validator) {
  delete validator_;
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ConsensusParams.validator)
}

// -------------------------------------------------------------------

// BlockSizeParams

// int64 max_bytes = 1;
inline void BlockSizeParams::clear_max_bytes() {
  max_bytes_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockSizeParams::max_bytes() const {
  // @@protoc_insertion_point(field_get:types.BlockSizeParams.max_bytes)
  return max_bytes_;
}
inline void BlockSizeParams::set_max_bytes(::google::protobuf::int64 value) {
  
  max_bytes_ = value;
  // @@protoc_insertion_point(field_set:types.BlockSizeParams.max_bytes)
}

// int64 max_gas = 2;
inline void BlockSizeParams::clear_max_gas() {
  max_gas_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BlockSizeParams::max_gas() const {
  // @@protoc_insertion_point(field_get:types.BlockSizeParams.max_gas)
  return max_gas_;
}
inline void BlockSizeParams::set_max_gas(::google::protobuf::int64 value) {
  
  max_gas_ = value;
  // @@protoc_insertion_point(field_set:types.BlockSizeParams.max_gas)
}

// -------------------------------------------------------------------

// EvidenceParams

// int64 max_age = 1;
inline void EvidenceParams::clear_max_age() {
  max_age_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 EvidenceParams::max_age() const {
  // @@protoc_insertion_point(field_get:types.EvidenceParams.max_age)
  return max_age_;
}
inline void EvidenceParams::set_max_age(::google::protobuf::int64 value) {
  
  max_age_ = value;
  // @@protoc_insertion_point(field_set:types.EvidenceParams.max_age)
}

// -------------------------------------------------------------------

// ValidatorParams

// repeated string pub_key_types = 1;
inline int ValidatorParams::pub_key_types_size() const {
  return pub_key_types_.size();
}
inline void ValidatorParams::clear_pub_key_types() {
  pub_key_types_.Clear();
}
inline const ::std::string& ValidatorParams::pub_key_types(int index) const {
  // @@protoc_insertion_point(field_get:types.ValidatorParams.pub_key_types)
  return pub_key_types_.Get(index);
}
inline ::std::string* ValidatorParams::mutable_pub_key_types(int index) {
  // @@protoc_insertion_point(field_mutable:types.ValidatorParams.pub_key_types)
  return pub_key_types_.Mutable(index);
}
inline void ValidatorParams::set_pub_key_types(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:types.ValidatorParams.pub_key_types)
  pub_key_types_.Mutable(index)->assign(value);
}
inline void ValidatorParams::set_pub_key_types(int index, const char* value) {
  pub_key_types_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:types.ValidatorParams.pub_key_types)
}
inline void ValidatorParams::set_pub_key_types(int index, const char* value, size_t size) {
  pub_key_types_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:types.ValidatorParams.pub_key_types)
}
inline ::std::string* ValidatorParams::add_pub_key_types() {
  // @@protoc_insertion_point(field_add_mutable:types.ValidatorParams.pub_key_types)
  return pub_key_types_.Add();
}
inline void ValidatorParams::add_pub_key_types(const ::std::string& value) {
  pub_key_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:types.ValidatorParams.pub_key_types)
}
inline void ValidatorParams::add_pub_key_types(const char* value) {
  pub_key_types_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:types.ValidatorParams.pub_key_types)
}
inline void ValidatorParams::add_pub_key_types(const char* value, size_t size) {
  pub_key_types_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:types.ValidatorParams.pub_key_types)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ValidatorParams::pub_key_types() const {
  // @@protoc_insertion_point(field_list:types.ValidatorParams.pub_key_types)
  return pub_key_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ValidatorParams::mutable_pub_key_types() {
  // @@protoc_insertion_point(field_mutable_list:types.ValidatorParams.pub_key_types)
  return &pub_key_types_;
}

// -------------------------------------------------------------------

// LastCommitInfo

// int32 round = 1;
inline void LastCommitInfo::clear_round() {
  round_ = 0;
}
inline ::google::protobuf::int32 LastCommitInfo::round() const {
  // @@protoc_insertion_point(field_get:types.LastCommitInfo.round)
  return round_;
}
inline void LastCommitInfo::set_round(::google::protobuf::int32 value) {
  
  round_ = value;
  // @@protoc_insertion_point(field_set:types.LastCommitInfo.round)
}

// repeated .types.VoteInfo votes = 2 [(.gogoproto.nullable) = false];
inline int LastCommitInfo::votes_size() const {
  return votes_.size();
}
inline void LastCommitInfo::clear_votes() {
  votes_.Clear();
}
inline const ::types::VoteInfo& LastCommitInfo::votes(int index) const {
  // @@protoc_insertion_point(field_get:types.LastCommitInfo.votes)
  return votes_.Get(index);
}
inline ::types::VoteInfo* LastCommitInfo::mutable_votes(int index) {
  // @@protoc_insertion_point(field_mutable:types.LastCommitInfo.votes)
  return votes_.Mutable(index);
}
inline ::types::VoteInfo* LastCommitInfo::add_votes() {
  // @@protoc_insertion_point(field_add:types.LastCommitInfo.votes)
  return votes_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::types::VoteInfo >*
LastCommitInfo::mutable_votes() {
  // @@protoc_insertion_point(field_mutable_list:types.LastCommitInfo.votes)
  return &votes_;
}
inline const ::google::protobuf::RepeatedPtrField< ::types::VoteInfo >&
LastCommitInfo::votes() const {
  // @@protoc_insertion_point(field_list:types.LastCommitInfo.votes)
  return votes_;
}

// -------------------------------------------------------------------

// Header

// .types.Version version = 1 [(.gogoproto.nullable) = false];
inline bool Header::has_version() const {
  return this != internal_default_instance() && version_ != NULL;
}
inline void Header::clear_version() {
  if (GetArenaNoVirtual() == NULL && version_ != NULL) delete version_;
  version_ = NULL;
}
inline const ::types::Version& Header::version() const {
  // @@protoc_insertion_point(field_get:types.Header.version)
  return version_ != NULL ? *version_
                         : *::types::Version::internal_default_instance();
}
inline ::types::Version* Header::mutable_version() {
  
  if (version_ == NULL) {
    version_ = new ::types::Version;
  }
  // @@protoc_insertion_point(field_mutable:types.Header.version)
  return version_;
}
inline ::types::Version* Header::release_version() {
  // @@protoc_insertion_point(field_release:types.Header.version)
  
  ::types::Version* temp = version_;
  version_ = NULL;
  return temp;
}
inline void Header::set_allocated_version(::types::Version* version) {
  delete version_;
  version_ = version;
  if (version) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.Header.version)
}

// string chain_id = 2 [(.gogoproto.customname) = "ChainID"];
inline void Header::clear_chain_id() {
  chain_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::chain_id() const {
  // @@protoc_insertion_point(field_get:types.Header.chain_id)
  return chain_id_.GetNoArena();
}
inline void Header::set_chain_id(const ::std::string& value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.chain_id)
}
#if LANG_CXX11
inline void Header::set_chain_id(::std::string&& value) {
  
  chain_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.chain_id)
}
#endif
inline void Header::set_chain_id(const char* value) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.chain_id)
}
inline void Header::set_chain_id(const char* value, size_t size) {
  
  chain_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.chain_id)
}
inline ::std::string* Header::mutable_chain_id() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.chain_id)
  return chain_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_chain_id() {
  // @@protoc_insertion_point(field_release:types.Header.chain_id)
  
  return chain_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_chain_id(::std::string* chain_id) {
  if (chain_id != NULL) {
    
  } else {
    
  }
  chain_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), chain_id);
  // @@protoc_insertion_point(field_set_allocated:types.Header.chain_id)
}

// int64 height = 3;
inline void Header::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::height() const {
  // @@protoc_insertion_point(field_get:types.Header.height)
  return height_;
}
inline void Header::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.Header.height)
}

// .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Header::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline void Header::clear_time() {
  if (GetArenaNoVirtual() == NULL && time_ != NULL) delete time_;
  time_ = NULL;
}
inline const ::google::protobuf::Timestamp& Header::time() const {
  // @@protoc_insertion_point(field_get:types.Header.time)
  return time_ != NULL ? *time_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* Header::mutable_time() {
  
  if (time_ == NULL) {
    time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:types.Header.time)
  return time_;
}
inline ::google::protobuf::Timestamp* Header::release_time() {
  // @@protoc_insertion_point(field_release:types.Header.time)
  
  ::google::protobuf::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Header::set_allocated_time(::google::protobuf::Timestamp* time) {
  delete time_;
  if (time != NULL && time->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_time = new ::google::protobuf::Timestamp;
    new_time->CopyFrom(*time);
    time = new_time;
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.Header.time)
}

// int64 num_txs = 5;
inline void Header::clear_num_txs() {
  num_txs_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::num_txs() const {
  // @@protoc_insertion_point(field_get:types.Header.num_txs)
  return num_txs_;
}
inline void Header::set_num_txs(::google::protobuf::int64 value) {
  
  num_txs_ = value;
  // @@protoc_insertion_point(field_set:types.Header.num_txs)
}

// int64 total_txs = 6;
inline void Header::clear_total_txs() {
  total_txs_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Header::total_txs() const {
  // @@protoc_insertion_point(field_get:types.Header.total_txs)
  return total_txs_;
}
inline void Header::set_total_txs(::google::protobuf::int64 value) {
  
  total_txs_ = value;
  // @@protoc_insertion_point(field_set:types.Header.total_txs)
}

// .types.BlockID last_block_id = 7 [(.gogoproto.nullable) = false];
inline bool Header::has_last_block_id() const {
  return this != internal_default_instance() && last_block_id_ != NULL;
}
inline void Header::clear_last_block_id() {
  if (GetArenaNoVirtual() == NULL && last_block_id_ != NULL) delete last_block_id_;
  last_block_id_ = NULL;
}
inline const ::types::BlockID& Header::last_block_id() const {
  // @@protoc_insertion_point(field_get:types.Header.last_block_id)
  return last_block_id_ != NULL ? *last_block_id_
                         : *::types::BlockID::internal_default_instance();
}
inline ::types::BlockID* Header::mutable_last_block_id() {
  
  if (last_block_id_ == NULL) {
    last_block_id_ = new ::types::BlockID;
  }
  // @@protoc_insertion_point(field_mutable:types.Header.last_block_id)
  return last_block_id_;
}
inline ::types::BlockID* Header::release_last_block_id() {
  // @@protoc_insertion_point(field_release:types.Header.last_block_id)
  
  ::types::BlockID* temp = last_block_id_;
  last_block_id_ = NULL;
  return temp;
}
inline void Header::set_allocated_last_block_id(::types::BlockID* last_block_id) {
  delete last_block_id_;
  last_block_id_ = last_block_id;
  if (last_block_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.Header.last_block_id)
}

// bytes last_commit_hash = 8;
inline void Header::clear_last_commit_hash() {
  last_commit_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::last_commit_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.last_commit_hash)
  return last_commit_hash_.GetNoArena();
}
inline void Header::set_last_commit_hash(const ::std::string& value) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.last_commit_hash)
}
#if LANG_CXX11
inline void Header::set_last_commit_hash(::std::string&& value) {
  
  last_commit_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.last_commit_hash)
}
#endif
inline void Header::set_last_commit_hash(const char* value) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.last_commit_hash)
}
inline void Header::set_last_commit_hash(const void* value, size_t size) {
  
  last_commit_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.last_commit_hash)
}
inline ::std::string* Header::mutable_last_commit_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.last_commit_hash)
  return last_commit_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_last_commit_hash() {
  // @@protoc_insertion_point(field_release:types.Header.last_commit_hash)
  
  return last_commit_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_last_commit_hash(::std::string* last_commit_hash) {
  if (last_commit_hash != NULL) {
    
  } else {
    
  }
  last_commit_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_commit_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.last_commit_hash)
}

// bytes data_hash = 9;
inline void Header::clear_data_hash() {
  data_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::data_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.data_hash)
  return data_hash_.GetNoArena();
}
inline void Header::set_data_hash(const ::std::string& value) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.data_hash)
}
#if LANG_CXX11
inline void Header::set_data_hash(::std::string&& value) {
  
  data_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.data_hash)
}
#endif
inline void Header::set_data_hash(const char* value) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.data_hash)
}
inline void Header::set_data_hash(const void* value, size_t size) {
  
  data_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.data_hash)
}
inline ::std::string* Header::mutable_data_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.data_hash)
  return data_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_data_hash() {
  // @@protoc_insertion_point(field_release:types.Header.data_hash)
  
  return data_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_data_hash(::std::string* data_hash) {
  if (data_hash != NULL) {
    
  } else {
    
  }
  data_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.data_hash)
}

// bytes validators_hash = 10;
inline void Header::clear_validators_hash() {
  validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::validators_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.validators_hash)
  return validators_hash_.GetNoArena();
}
inline void Header::set_validators_hash(const ::std::string& value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.validators_hash)
}
#if LANG_CXX11
inline void Header::set_validators_hash(::std::string&& value) {
  
  validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.validators_hash)
}
#endif
inline void Header::set_validators_hash(const char* value) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.validators_hash)
}
inline void Header::set_validators_hash(const void* value, size_t size) {
  
  validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.validators_hash)
}
inline ::std::string* Header::mutable_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.validators_hash)
  return validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_validators_hash() {
  // @@protoc_insertion_point(field_release:types.Header.validators_hash)
  
  return validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_validators_hash(::std::string* validators_hash) {
  if (validators_hash != NULL) {
    
  } else {
    
  }
  validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), validators_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.validators_hash)
}

// bytes next_validators_hash = 11;
inline void Header::clear_next_validators_hash() {
  next_validators_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::next_validators_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.next_validators_hash)
  return next_validators_hash_.GetNoArena();
}
inline void Header::set_next_validators_hash(const ::std::string& value) {
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.next_validators_hash)
}
#if LANG_CXX11
inline void Header::set_next_validators_hash(::std::string&& value) {
  
  next_validators_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.next_validators_hash)
}
#endif
inline void Header::set_next_validators_hash(const char* value) {
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.next_validators_hash)
}
inline void Header::set_next_validators_hash(const void* value, size_t size) {
  
  next_validators_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.next_validators_hash)
}
inline ::std::string* Header::mutable_next_validators_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.next_validators_hash)
  return next_validators_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_next_validators_hash() {
  // @@protoc_insertion_point(field_release:types.Header.next_validators_hash)
  
  return next_validators_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_next_validators_hash(::std::string* next_validators_hash) {
  if (next_validators_hash != NULL) {
    
  } else {
    
  }
  next_validators_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), next_validators_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.next_validators_hash)
}

// bytes consensus_hash = 12;
inline void Header::clear_consensus_hash() {
  consensus_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::consensus_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.consensus_hash)
  return consensus_hash_.GetNoArena();
}
inline void Header::set_consensus_hash(const ::std::string& value) {
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.consensus_hash)
}
#if LANG_CXX11
inline void Header::set_consensus_hash(::std::string&& value) {
  
  consensus_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.consensus_hash)
}
#endif
inline void Header::set_consensus_hash(const char* value) {
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.consensus_hash)
}
inline void Header::set_consensus_hash(const void* value, size_t size) {
  
  consensus_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.consensus_hash)
}
inline ::std::string* Header::mutable_consensus_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.consensus_hash)
  return consensus_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_consensus_hash() {
  // @@protoc_insertion_point(field_release:types.Header.consensus_hash)
  
  return consensus_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_consensus_hash(::std::string* consensus_hash) {
  if (consensus_hash != NULL) {
    
  } else {
    
  }
  consensus_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), consensus_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.consensus_hash)
}

// bytes app_hash = 13;
inline void Header::clear_app_hash() {
  app_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::app_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.app_hash)
  return app_hash_.GetNoArena();
}
inline void Header::set_app_hash(const ::std::string& value) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.app_hash)
}
#if LANG_CXX11
inline void Header::set_app_hash(::std::string&& value) {
  
  app_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.app_hash)
}
#endif
inline void Header::set_app_hash(const char* value) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.app_hash)
}
inline void Header::set_app_hash(const void* value, size_t size) {
  
  app_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.app_hash)
}
inline ::std::string* Header::mutable_app_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.app_hash)
  return app_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_app_hash() {
  // @@protoc_insertion_point(field_release:types.Header.app_hash)
  
  return app_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_app_hash(::std::string* app_hash) {
  if (app_hash != NULL) {
    
  } else {
    
  }
  app_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.app_hash)
}

// bytes last_results_hash = 14;
inline void Header::clear_last_results_hash() {
  last_results_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::last_results_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.last_results_hash)
  return last_results_hash_.GetNoArena();
}
inline void Header::set_last_results_hash(const ::std::string& value) {
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.last_results_hash)
}
#if LANG_CXX11
inline void Header::set_last_results_hash(::std::string&& value) {
  
  last_results_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.last_results_hash)
}
#endif
inline void Header::set_last_results_hash(const char* value) {
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.last_results_hash)
}
inline void Header::set_last_results_hash(const void* value, size_t size) {
  
  last_results_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.last_results_hash)
}
inline ::std::string* Header::mutable_last_results_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.last_results_hash)
  return last_results_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_last_results_hash() {
  // @@protoc_insertion_point(field_release:types.Header.last_results_hash)
  
  return last_results_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_last_results_hash(::std::string* last_results_hash) {
  if (last_results_hash != NULL) {
    
  } else {
    
  }
  last_results_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), last_results_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.last_results_hash)
}

// bytes evidence_hash = 15;
inline void Header::clear_evidence_hash() {
  evidence_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::evidence_hash() const {
  // @@protoc_insertion_point(field_get:types.Header.evidence_hash)
  return evidence_hash_.GetNoArena();
}
inline void Header::set_evidence_hash(const ::std::string& value) {
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.evidence_hash)
}
#if LANG_CXX11
inline void Header::set_evidence_hash(::std::string&& value) {
  
  evidence_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.evidence_hash)
}
#endif
inline void Header::set_evidence_hash(const char* value) {
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.evidence_hash)
}
inline void Header::set_evidence_hash(const void* value, size_t size) {
  
  evidence_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.evidence_hash)
}
inline ::std::string* Header::mutable_evidence_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.evidence_hash)
  return evidence_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_evidence_hash() {
  // @@protoc_insertion_point(field_release:types.Header.evidence_hash)
  
  return evidence_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_evidence_hash(::std::string* evidence_hash) {
  if (evidence_hash != NULL) {
    
  } else {
    
  }
  evidence_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), evidence_hash);
  // @@protoc_insertion_point(field_set_allocated:types.Header.evidence_hash)
}

// bytes proposer_address = 16;
inline void Header::clear_proposer_address() {
  proposer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Header::proposer_address() const {
  // @@protoc_insertion_point(field_get:types.Header.proposer_address)
  return proposer_address_.GetNoArena();
}
inline void Header::set_proposer_address(const ::std::string& value) {
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Header.proposer_address)
}
#if LANG_CXX11
inline void Header::set_proposer_address(::std::string&& value) {
  
  proposer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Header.proposer_address)
}
#endif
inline void Header::set_proposer_address(const char* value) {
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Header.proposer_address)
}
inline void Header::set_proposer_address(const void* value, size_t size) {
  
  proposer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Header.proposer_address)
}
inline ::std::string* Header::mutable_proposer_address() {
  
  // @@protoc_insertion_point(field_mutable:types.Header.proposer_address)
  return proposer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Header::release_proposer_address() {
  // @@protoc_insertion_point(field_release:types.Header.proposer_address)
  
  return proposer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Header::set_allocated_proposer_address(::std::string* proposer_address) {
  if (proposer_address != NULL) {
    
  } else {
    
  }
  proposer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proposer_address);
  // @@protoc_insertion_point(field_set_allocated:types.Header.proposer_address)
}

// -------------------------------------------------------------------

// Version

// uint64 Block = 1;
inline void Version::clear_block() {
  block_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Version::block() const {
  // @@protoc_insertion_point(field_get:types.Version.Block)
  return block_;
}
inline void Version::set_block(::google::protobuf::uint64 value) {
  
  block_ = value;
  // @@protoc_insertion_point(field_set:types.Version.Block)
}

// uint64 App = 2;
inline void Version::clear_app() {
  app_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Version::app() const {
  // @@protoc_insertion_point(field_get:types.Version.App)
  return app_;
}
inline void Version::set_app(::google::protobuf::uint64 value) {
  
  app_ = value;
  // @@protoc_insertion_point(field_set:types.Version.App)
}

// -------------------------------------------------------------------

// BlockID

// bytes hash = 1;
inline void BlockID::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BlockID::hash() const {
  // @@protoc_insertion_point(field_get:types.BlockID.hash)
  return hash_.GetNoArena();
}
inline void BlockID::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.BlockID.hash)
}
#if LANG_CXX11
inline void BlockID::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.BlockID.hash)
}
#endif
inline void BlockID::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.BlockID.hash)
}
inline void BlockID::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.BlockID.hash)
}
inline ::std::string* BlockID::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.BlockID.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BlockID::release_hash() {
  // @@protoc_insertion_point(field_release:types.BlockID.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BlockID::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.BlockID.hash)
}

// .types.PartSetHeader parts_header = 2 [(.gogoproto.nullable) = false];
inline bool BlockID::has_parts_header() const {
  return this != internal_default_instance() && parts_header_ != NULL;
}
inline void BlockID::clear_parts_header() {
  if (GetArenaNoVirtual() == NULL && parts_header_ != NULL) delete parts_header_;
  parts_header_ = NULL;
}
inline const ::types::PartSetHeader& BlockID::parts_header() const {
  // @@protoc_insertion_point(field_get:types.BlockID.parts_header)
  return parts_header_ != NULL ? *parts_header_
                         : *::types::PartSetHeader::internal_default_instance();
}
inline ::types::PartSetHeader* BlockID::mutable_parts_header() {
  
  if (parts_header_ == NULL) {
    parts_header_ = new ::types::PartSetHeader;
  }
  // @@protoc_insertion_point(field_mutable:types.BlockID.parts_header)
  return parts_header_;
}
inline ::types::PartSetHeader* BlockID::release_parts_header() {
  // @@protoc_insertion_point(field_release:types.BlockID.parts_header)
  
  ::types::PartSetHeader* temp = parts_header_;
  parts_header_ = NULL;
  return temp;
}
inline void BlockID::set_allocated_parts_header(::types::PartSetHeader* parts_header) {
  delete parts_header_;
  parts_header_ = parts_header;
  if (parts_header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.BlockID.parts_header)
}

// -------------------------------------------------------------------

// PartSetHeader

// int32 total = 1;
inline void PartSetHeader::clear_total() {
  total_ = 0;
}
inline ::google::protobuf::int32 PartSetHeader::total() const {
  // @@protoc_insertion_point(field_get:types.PartSetHeader.total)
  return total_;
}
inline void PartSetHeader::set_total(::google::protobuf::int32 value) {
  
  total_ = value;
  // @@protoc_insertion_point(field_set:types.PartSetHeader.total)
}

// bytes hash = 2;
inline void PartSetHeader::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartSetHeader::hash() const {
  // @@protoc_insertion_point(field_get:types.PartSetHeader.hash)
  return hash_.GetNoArena();
}
inline void PartSetHeader::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.PartSetHeader.hash)
}
#if LANG_CXX11
inline void PartSetHeader::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.PartSetHeader.hash)
}
#endif
inline void PartSetHeader::set_hash(const char* value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.PartSetHeader.hash)
}
inline void PartSetHeader::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.PartSetHeader.hash)
}
inline ::std::string* PartSetHeader::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:types.PartSetHeader.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartSetHeader::release_hash() {
  // @@protoc_insertion_point(field_release:types.PartSetHeader.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartSetHeader::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:types.PartSetHeader.hash)
}

// -------------------------------------------------------------------

// Validator

// bytes address = 1;
inline void Validator::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Validator::address() const {
  // @@protoc_insertion_point(field_get:types.Validator.address)
  return address_.GetNoArena();
}
inline void Validator::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Validator.address)
}
#if LANG_CXX11
inline void Validator::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Validator.address)
}
#endif
inline void Validator::set_address(const char* value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Validator.address)
}
inline void Validator::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Validator.address)
}
inline ::std::string* Validator::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:types.Validator.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Validator::release_address() {
  // @@protoc_insertion_point(field_release:types.Validator.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Validator::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:types.Validator.address)
}

// int64 power = 3;
inline void Validator::clear_power() {
  power_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Validator::power() const {
  // @@protoc_insertion_point(field_get:types.Validator.power)
  return power_;
}
inline void Validator::set_power(::google::protobuf::int64 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:types.Validator.power)
}

// -------------------------------------------------------------------

// ValidatorUpdate

// .types.PubKey pub_key = 1 [(.gogoproto.nullable) = false];
inline bool ValidatorUpdate::has_pub_key() const {
  return this != internal_default_instance() && pub_key_ != NULL;
}
inline void ValidatorUpdate::clear_pub_key() {
  if (GetArenaNoVirtual() == NULL && pub_key_ != NULL) delete pub_key_;
  pub_key_ = NULL;
}
inline const ::types::PubKey& ValidatorUpdate::pub_key() const {
  // @@protoc_insertion_point(field_get:types.ValidatorUpdate.pub_key)
  return pub_key_ != NULL ? *pub_key_
                         : *::types::PubKey::internal_default_instance();
}
inline ::types::PubKey* ValidatorUpdate::mutable_pub_key() {
  
  if (pub_key_ == NULL) {
    pub_key_ = new ::types::PubKey;
  }
  // @@protoc_insertion_point(field_mutable:types.ValidatorUpdate.pub_key)
  return pub_key_;
}
inline ::types::PubKey* ValidatorUpdate::release_pub_key() {
  // @@protoc_insertion_point(field_release:types.ValidatorUpdate.pub_key)
  
  ::types::PubKey* temp = pub_key_;
  pub_key_ = NULL;
  return temp;
}
inline void ValidatorUpdate::set_allocated_pub_key(::types::PubKey* pub_key) {
  delete pub_key_;
  pub_key_ = pub_key;
  if (pub_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.ValidatorUpdate.pub_key)
}

// int64 power = 2;
inline void ValidatorUpdate::clear_power() {
  power_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ValidatorUpdate::power() const {
  // @@protoc_insertion_point(field_get:types.ValidatorUpdate.power)
  return power_;
}
inline void ValidatorUpdate::set_power(::google::protobuf::int64 value) {
  
  power_ = value;
  // @@protoc_insertion_point(field_set:types.ValidatorUpdate.power)
}

// -------------------------------------------------------------------

// VoteInfo

// .types.Validator validator = 1 [(.gogoproto.nullable) = false];
inline bool VoteInfo::has_validator() const {
  return this != internal_default_instance() && validator_ != NULL;
}
inline void VoteInfo::clear_validator() {
  if (GetArenaNoVirtual() == NULL && validator_ != NULL) delete validator_;
  validator_ = NULL;
}
inline const ::types::Validator& VoteInfo::validator() const {
  // @@protoc_insertion_point(field_get:types.VoteInfo.validator)
  return validator_ != NULL ? *validator_
                         : *::types::Validator::internal_default_instance();
}
inline ::types::Validator* VoteInfo::mutable_validator() {
  
  if (validator_ == NULL) {
    validator_ = new ::types::Validator;
  }
  // @@protoc_insertion_point(field_mutable:types.VoteInfo.validator)
  return validator_;
}
inline ::types::Validator* VoteInfo::release_validator() {
  // @@protoc_insertion_point(field_release:types.VoteInfo.validator)
  
  ::types::Validator* temp = validator_;
  validator_ = NULL;
  return temp;
}
inline void VoteInfo::set_allocated_validator(::types::Validator* validator) {
  delete validator_;
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.VoteInfo.validator)
}

// bool signed_last_block = 2;
inline void VoteInfo::clear_signed_last_block() {
  signed_last_block_ = false;
}
inline bool VoteInfo::signed_last_block() const {
  // @@protoc_insertion_point(field_get:types.VoteInfo.signed_last_block)
  return signed_last_block_;
}
inline void VoteInfo::set_signed_last_block(bool value) {
  
  signed_last_block_ = value;
  // @@protoc_insertion_point(field_set:types.VoteInfo.signed_last_block)
}

// -------------------------------------------------------------------

// PubKey

// string type = 1;
inline void PubKey::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubKey::type() const {
  // @@protoc_insertion_point(field_get:types.PubKey.type)
  return type_.GetNoArena();
}
inline void PubKey::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.PubKey.type)
}
#if LANG_CXX11
inline void PubKey::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.PubKey.type)
}
#endif
inline void PubKey::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.PubKey.type)
}
inline void PubKey::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.PubKey.type)
}
inline ::std::string* PubKey::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:types.PubKey.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubKey::release_type() {
  // @@protoc_insertion_point(field_release:types.PubKey.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubKey::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:types.PubKey.type)
}

// bytes data = 2;
inline void PubKey::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PubKey::data() const {
  // @@protoc_insertion_point(field_get:types.PubKey.data)
  return data_.GetNoArena();
}
inline void PubKey::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.PubKey.data)
}
#if LANG_CXX11
inline void PubKey::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.PubKey.data)
}
#endif
inline void PubKey::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.PubKey.data)
}
inline void PubKey::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.PubKey.data)
}
inline ::std::string* PubKey::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:types.PubKey.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PubKey::release_data() {
  // @@protoc_insertion_point(field_release:types.PubKey.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PubKey::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:types.PubKey.data)
}

// -------------------------------------------------------------------

// Evidence

// string type = 1;
inline void Evidence::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Evidence::type() const {
  // @@protoc_insertion_point(field_get:types.Evidence.type)
  return type_.GetNoArena();
}
inline void Evidence::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Evidence.type)
}
#if LANG_CXX11
inline void Evidence::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Evidence.type)
}
#endif
inline void Evidence::set_type(const char* value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Evidence.type)
}
inline void Evidence::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Evidence.type)
}
inline ::std::string* Evidence::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:types.Evidence.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Evidence::release_type() {
  // @@protoc_insertion_point(field_release:types.Evidence.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Evidence::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:types.Evidence.type)
}

// .types.Validator validator = 2 [(.gogoproto.nullable) = false];
inline bool Evidence::has_validator() const {
  return this != internal_default_instance() && validator_ != NULL;
}
inline void Evidence::clear_validator() {
  if (GetArenaNoVirtual() == NULL && validator_ != NULL) delete validator_;
  validator_ = NULL;
}
inline const ::types::Validator& Evidence::validator() const {
  // @@protoc_insertion_point(field_get:types.Evidence.validator)
  return validator_ != NULL ? *validator_
                         : *::types::Validator::internal_default_instance();
}
inline ::types::Validator* Evidence::mutable_validator() {
  
  if (validator_ == NULL) {
    validator_ = new ::types::Validator;
  }
  // @@protoc_insertion_point(field_mutable:types.Evidence.validator)
  return validator_;
}
inline ::types::Validator* Evidence::release_validator() {
  // @@protoc_insertion_point(field_release:types.Evidence.validator)
  
  ::types::Validator* temp = validator_;
  validator_ = NULL;
  return temp;
}
inline void Evidence::set_allocated_validator(::types::Validator* validator) {
  delete validator_;
  validator_ = validator;
  if (validator) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.Evidence.validator)
}

// int64 height = 3;
inline void Evidence::clear_height() {
  height_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Evidence::height() const {
  // @@protoc_insertion_point(field_get:types.Evidence.height)
  return height_;
}
inline void Evidence::set_height(::google::protobuf::int64 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:types.Evidence.height)
}

// .google.protobuf.Timestamp time = 4 [(.gogoproto.nullable) = false, (.gogoproto.stdtime) = true];
inline bool Evidence::has_time() const {
  return this != internal_default_instance() && time_ != NULL;
}
inline void Evidence::clear_time() {
  if (GetArenaNoVirtual() == NULL && time_ != NULL) delete time_;
  time_ = NULL;
}
inline const ::google::protobuf::Timestamp& Evidence::time() const {
  // @@protoc_insertion_point(field_get:types.Evidence.time)
  return time_ != NULL ? *time_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* Evidence::mutable_time() {
  
  if (time_ == NULL) {
    time_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:types.Evidence.time)
  return time_;
}
inline ::google::protobuf::Timestamp* Evidence::release_time() {
  // @@protoc_insertion_point(field_release:types.Evidence.time)
  
  ::google::protobuf::Timestamp* temp = time_;
  time_ = NULL;
  return temp;
}
inline void Evidence::set_allocated_time(::google::protobuf::Timestamp* time) {
  delete time_;
  if (time != NULL && time->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_time = new ::google::protobuf::Timestamp;
    new_time->CopyFrom(*time);
    time = new_time;
  }
  time_ = time;
  if (time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:types.Evidence.time)
}

// int64 total_voting_power = 5;
inline void Evidence::clear_total_voting_power() {
  total_voting_power_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Evidence::total_voting_power() const {
  // @@protoc_insertion_point(field_get:types.Evidence.total_voting_power)
  return total_voting_power_;
}
inline void Evidence::set_total_voting_power(::google::protobuf::int64 value) {
  
  total_voting_power_ = value;
  // @@protoc_insertion_point(field_set:types.Evidence.total_voting_power)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace types

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_types_2eproto__INCLUDED
