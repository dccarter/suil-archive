//
// Created by dc on 10/11/18.
//

#ifndef SUIL_LOGGING_H
#define SUIL_LOGGING_H

#include <functional>
#include <iod/options.hh>

#include <suil/base.h>

#ifndef SUIL_LOG_BUFFER_SIZE
#define SUIL_LOG_BUFFER_SIZE 2048
#endif

namespace suil {

    namespace log {

#ifdef SUIL_BACKTRACE
        /**
         * capture the current backtrace into the given buffer
         * @param buf the buffer to dump the stack trace into
         * @size the size of the buffer
         */
        void backtrace(char *buf, size_t size);
#else
#define  backtrace(buf, size)
#endif

        /**
         * an enum of supported log levels
         */
        typedef enum : unsigned char {
            TRACE,
            DEBUG,
            INFO,
            NOTICE,
            WARNING,
            ERROR,
            CRITICAL
        } Level;

        /**
         * The default log formatter. Log formatters can be changed
         * to change the output style of the log
         * @see \def LogFormat
         */
        struct Formatter {
            size_t operator()(char *out,
                              Level l,
                              const char *tag,
                              const char *fmt,
                              va_list args);
        };

        /**
         * Log formatter template
         * @param out formatter shuld format into this buffer, it size is always 2048_B
         * @param l the log level that produced this log
         * @param tag the logging tag that produced the log
         * @param fmt c-style printf format string
         * @param args variable arguments list
         *
         * @return must return the number of bytes written into the buffer
         */
        using LogFormat = std::function<size_t(char *out, Level l, const char * tag, const char *fmt, va_list args)>;

        /**
         * default log sink accepts the formatted log message and prints it to console
         * color coded
         */
        struct Handler {
            void operator()(const char *log, size_t, Level);
        };

        /**
         * Log sink sink template
         * @param msg the formatted log message
         * @param size the size of the message
         * @param l the logging level that produced the message
         */
        using LogSink = std::function<void(const char *msg, size_t size, Level l)>;

        /**
         * define a log tag which can be attached to a class
         * @param the name that will be used to tag log messages generated by the
         * class tagged with this tag
         */
#define define_log_tag(name) \
        struct name##_log_tag {\
            static constexpr char *TAG = (char *)#name; \
        }
        /**
         * get the fully qualified name of the tag
         * @param name
         */
#define dtag(name)   name##_log_tag

        define_log_tag(SYSTEM);

        template<class __T = dtag(SYSTEM)>
        struct Logger {
            Logger() {}

            Logger(const char *tag)
                    : tag(::strdup(tag)) {}

            void log(Level l, const char *fmt, ...) const;

            virtual ~Logger() {
                if (tag) {
                    free(tag);
                    tag = nullptr;
                }
            }

        protected:
            LogSink psink{nullptr};
        private:
            char *tag{nullptr};
        };

        struct __Logger : public Logger<> {
            __Logger() {
                sink =
                        [&](const char *msg, size_t sz, Level l) {
                            Handler()(msg, sz, l);
                        };

                formatter =
                        [&](char *out, Level l, const char *tag, const char *fmt, va_list args) {
                            return Formatter()(out, l, tag, fmt, args);
                        };
            }

            Level getLevel() const {
                return lvl;
            }

            inline void fwdlogs(const char *log, size_t sz, Level l) {
                if (psink = nullptr) {
                    psink(log, sz, l);
                } else if (sink != nullptr) {
                    sink(log, sz, l);
                }
            }

            inline size_t format(char *out, Level l, const char *tag, const char *fmt, va_list args) {
                if (formatter != nullptr) {
                    return formatter(out, l, tag, fmt, args);
                }

                return 0;
            }

            inline const char *app_name() const {
                return appname;
            }

            template<typename... Opts>
            void setup(Opts... opts) {
                auto options = iod::D(opts...);

                int l = options.get(sym(verbose), -1);
                if (l >= TRACE && l <= log::CRITICAL) {
                    /* set log level */
                    Ego.lvl = (Level) l;
                }

                LogSink sink = options.get(sym(sink), nullptr);
                if (sink != nullptr) {
                    /* set log sink */
                    Ego.sink = std::move(sink);
                }

                LogFormat fmt = options.get(sym(format), nullptr);
                if (fmt != nullptr) {
                    /* set log formatter */
                    Ego.formatter = std::move(fmt);
                }

                const char *name = options.get(sym(name), nullptr);
                if (name) {
                    if (Ego.appname) {
                        /* free duplicated name */
                        free(Ego.appname);
                    }
                    Ego.appname = ::strdup(name);
                }
            }

        private:
            LogSink sink{nullptr};
            Level lvl{DEBUG};
            LogFormat formatter{nullptr};
            char *appname{nullptr};
        };
    }

    extern log::__Logger &__Log;

    namespace log {

        template<typename T>
        void Logger<T>::log(Level l, const char *fmt, ...) const {
            char buf[SUIL_LOG_BUFFER_SIZE];
            va_list args;
            va_start(args, fmt);
            size_t sz = __Log.format(buf, l, T::TAG, fmt, args);
            va_end(args);

            if (sz > 0) {
                // forward logs to their destination
                __Log.fwdlogs(buf, sz, l);
            }

            if (l == Level::CRITICAL) {
                // print stack trace
                backtrace(buf, SUIL_LOG_BUFFER_SIZE);
            }
        }

        /**
         * configure the logger with different options
         * @tparam Opts option types, deduced
         * @param opts list of options in form opt(name, value),...
         *
         * @note the following are the supported options and are all optional
         * @code
         * opt(verbose, Level) -    // the accepted logging verbosity
         * opt(format,  LogFormat)  // a formatting callback function
         * opt(sink,    LogSink)    // the logging, where all logs are sent
         * opt(name,    const char) // the name of the logging application
         * @endcode
         */
        template<typename... Opts>
        inline static void setup(Opts... opts) {
            __Log.setup(std::forward<Opts>(opts)...);
        }
    }

    struct Syslog {

        Syslog(const char *name = "suil");

        virtual void log(const char *, size_t, log::Level);

        void close();

        inline ~Syslog() {
            Ego.close();
        }
    };
}

/**
 * used to attach a logger to a class by inheriting the tag
 * @example
 * @code
 *
 * define_log_tag(HTTP);
 *
 * struct Connection: LOGGER(HTTP) {
 *    ...
 * };
 *
 * @endcode
 */
#define LOGGER(tag) suil::log::Logger<dtag(tag)>

#define __LOG(sub, l, fmt, ...)                                 \
    if (suil::__Log.getLevel() <= (suil::log::Level:: l))       \
        (sub)->log(suil::log::Level:: l , fmt , ##__VA_ARGS__)

/**
 * log a debug message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define ldebug(sub, fmt, ...)    __LOG(sub, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a debug message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define idebug(fmt, ...)         __LOG(this, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a debug message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define sdebug(fmt, ...)         __LOG(&suil::__Log, DEBUG, fmt, ##__VA_ARGS__)
/**
 * log a warning message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lwarn(sub, fmt, ...)     __LOG(sub, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a warning message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define iwarn(fmt, ...)           __LOG(this, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a warning message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define swarn(fmt, ...)          __LOG(&suil::__Log, WARNING, fmt, ##__VA_ARGS__)
/**
 * log a info message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define linfo(sub, fmt, ...)     __LOG(sub, INFO, fmt, ##__VA_ARGS__)
/**
 * log a info message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define iinfo(fmt, ...)           __LOG(this, INFO, fmt, ##__VA_ARGS__)
/**
 * log a info message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define sinfo(fmt, ...)          __LOG(&suil::__Log, INFO, fmt, ##__VA_ARGS__)
/**
 * log a notice message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lnotice(sub, fmt, ...)   __LOG(sub, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a notice message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define inotice(fmt, ...)         __LOG(this, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a notice message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define snotice(fmt, ...)        __LOG(&suil::__Log, NOTICE, fmt, ##__VA_ARGS__)
/**
 * log a error message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lerror(sub, fmt, ...)    __LOG(sub, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a error message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define ierror(fmt, ...)          __LOG(this, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a error message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define serror(fmt, ...)         __LOG(&suil::__Log, ERROR, fmt, ##__VA_ARGS__)
/**
 * log a critical message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define lcritical(sub, fmt, ...) __LOG(sub, CRITICAL, fmt, ##__VA_ARGS__)
/**
 * log a critical message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define icritical(fmt, ...)       __LOG(this, CRITICAL, fmt, ##__VA_ARGS__)
/**
 * log a critical message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define scritical(fmt, ...)      __LOG(&suil::__Log, CRITICAL, fmt, ##__VA_ARGS__)

#if SUIL_TRACE_ENABLED
/**
 * log a trace message using the given logging class \param sub
 * @param sub
 * @param fmt
 * @param ...
 */
#define ltrace(l, fmt, ...)                                           \
    if (suil::__Log.getLevel() <= suil::log::Level::TRACE)                   \
        (l)->log(suil::log::Level::TRACE, "%s:%d " fmt, __FILE__,     \
                    __LINE__, ##__VA_ARGS__)
/**
 * log a trace message using current class tag (must have a tag attached)
 * @param fmt
 * @param ...
 */
#define trace(fmt, ...)  ltrace(this, fmt, ##__VA_ARGS__)
/**
 * log a trace message using system tag (SYSTEM)
 * @param fmt
 * @param ...
 */
#define strace(fmt, ...) ltrace(&suil::__Log, fmt, ##__VA_ARGS__)

#else

#define ltrace(l, fmt, ...)
#define trace(fmt, ...)
#define strace(fmt, ...)

#endif

#endif //SUIL_LOGGING_H
